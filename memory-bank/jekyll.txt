assets/index
-----------------------------------------------------------
Assets Jekyll provides built-in support for Sass and can work with CoffeeScript via a Ruby gem. In order to use them, you must first create a file with the proper extension name (one of .sass, .scss, or .coffee) and start the file with two lines of triple dashes, like this: ---
---
// start content
.my-definition
  font-size: 1.2em
 Jekyll treats these files the same as a regular page, in that the output file will be placed in the same directory that it came from. For instance, if you have a file named css/styles.scss in your siteâ€™s source folder, Jekyll will process it and put it in your siteâ€™s destination folder under css/styles.css.  Jekyll processes all Liquid filters and tags in asset files If you are using Mustache or another JavaScript templating language that conflicts with the Liquid template syntax, you will need to place {% raw %} and {% endraw %} tags around your code.  Sass/SCSS Jekyll allows you to customize your Sass conversion in certain ways. Place all your partials in your sass_dir, which defaults to <source>/_sass. Place your main SCSS or Sass files in the place you want them to be in the output file, such as <source>/css. For an example, take a look at this example site using Sass support in Jekyll. If you are using Sass @import statements, youâ€™ll need to ensure that your sass_dir is set to the base directory that contains your Sass files: sass:
    sass_dir: _sass
 The Sass converter will default the sass_dir configuration option to _sass.  The sass_dir is only used by Sass  Note that the sass_dir becomes the load path for Sass imports, nothing more. This means that Jekyll does not know about these files directly. Any files here should not contain the empty front matter as described above. If they do, they'll not be transformed as described above. This folder should only contain imports.   You may also specify the output style with the style option in your _config.yml file: sass:
    style: compressed
 These are passed to Sass, so any output style options Sass supports are valid here, too. Coffeescript To enable Coffeescript in Jekyll 3.0 and up you must  Install the jekyll-coffeescript gem Ensure that your _config.yml is up-to-date and includes the following:  plugins:
  - jekyll-coffeescript

    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/assets/


collections/index
-----------------------------------------------------------
Collections Collections are a great way to group related content like members of a team or talks at a conference. Setup To use a Collection you first need to define it in your _config.yml. For example hereâ€™s a collection of staff members: collections:
  - staff_members
 In this case collections is defined as a sequence (i.e array) with no additional metadata defined for each collection. You can optionally specify metadata for your collection by defining collections as a mapping (i.e hashmap) instead of sequence, and then defining additional fields in it: collections:
  staff_members:
    people: true
 When defining a collection as a sequence, its pages will not be rendered by default. To enable this, output: true must be specified on the collection, which requires defining the collection as a mapping. For more information, see the section Output.  Gather your collections3.7.0  You can optionally specify a directory to store all your collections in the same place with collections_dir: my_collections. Then Jekyll will look in my_collections/_books for the books collection, and in my_collections/_recipes for the recipes collection.   Be sure to move drafts and posts into custom collections directory If you specify a directory to store all your collections in the same place with collections_dir: my_collections, then you will need to move your _drafts and _posts directory to my_collections/_drafts and my_collections/_posts. Note that, the name of your collections directory cannot start with an underscore (`_`).  Add content Create a corresponding folder (e.g. <source>/_staff_members) and add documents. Front matter is processed if the front matter exists, and everything after the front matter is pushed into the documentâ€™s content attribute. If no front matter is provided, Jekyll will consider it to be a static file and the contents will not undergo further processing. If front matter is provided, Jekyll will process the file contents into the expected output. Regardless of whether front matter exists or not, Jekyll will write to the destination directory (e.g. _site) only if output: true has been set in the collectionâ€™s metadata. For example hereâ€™s how you would add a staff member to the collection set above. The filename is ./_staff_members/jane.md with the following content: ---
name: Jane Doe
position: Developer
---
Jane has worked on Jekyll for the past *five years*.
  Do note that in spite of being considered as a collection internally, the above doesnâ€™t apply to posts. Posts with a valid filename format will be marked for processing even if they do not contain front matter.   Be sure to name your directories correctly  The folder must be named identically to the collection you defined in your _config.yml file, with the addition of the preceding _ character.   Output Now you can iterate over site.staff_members on a page and output the content for each staff member. Similar to posts, the body of the document is accessed using the content variable: {% for staff_member in site.staff_members %}
  <h2>{{ staff_member.name }} - {{ staff_member.position }}</h2>
  <p>{{ staff_member.content | markdownify }}</p>
{% endfor %}
 If youâ€™d like Jekyll to create a rendered page for each document in your collection, you can set the output key to true in your collection metadata in _config.yml: collections:
  staff_members:
    output: true
 You can link to the generated page using the url attribute: {% for staff_member in site.staff_members %}
  <h2>
    <a href="{{ staff_member.url }}">
      {{ staff_member.name }} - {{ staff_member.position }}
    </a>
  </h2>
  <p>{{ staff_member.content | markdownify }}</p>
{% endfor %}
 Permalinks There are special permalink variables for collections to help you control the output url for the entire collection. Custom Sorting of Documents4.0
 By default, two documents in a collection are sorted by their date attribute when both of them have the date key in their front matter. However, if either or both documents do not have the date key in their front matter, they are sorted by their respective paths. You can control this sorting via the collectionâ€™s metadata. Sort By Front Matter Key Documents can be sorted based on a front matter key by setting a sort_by metadata to the front matter key string. For example, to sort a collection of tutorials based on key lesson, the configuration would be: collections:
  tutorials:
    sort_by: lesson
 The documents are arranged in the increasing order of the keyâ€™s value. If a document does not have the front matter key defined then that document is placed immediately after sorted documents. When multiple documents do not have the front matter key defined, those documents are sorted by their dates or paths and then placed immediately after the sorted documents. Manually Ordering Documents You can also manually order the documents by setting an order metadata with the filenames listed in the desired order. For example, a collection of tutorials would be configured as: collections:
  tutorials:
    order:
      - hello-world.md
      - introduction.md
      - basic-concepts.md
      - advanced-concepts.md
 Any documents with filenames that do not match the list entry simply gets placed after the rearranged documents. If a document is nested under subdirectories, include them in entries as well: collections:
  tutorials:
    order:
      - hello-world.md
      - introduction.md
      - concepts/basics.md
      - concepts/advanced.md
 If both metadata keys have been defined properly, order list takes precedence. Liquid Attributes Collections Collections are also available under site.collections, with the metadata you specified in your _config.yml (if present) and the following information:     Variable Description      label    The name of your collection, e.g. my_collection.      docs    An array of documents.      files    An array of static files in the collection.      relative_directory    The path to the collection's source directory, relative to the site source.      directory    The full path to the collections's source directory.      output    Whether the collection's documents will be output as individual files.        A Hard-Coded Collection In addition to any collections you create yourself, the posts collection is hard-coded into Jekyll. It exists whether you have a _posts directory or not. This is something to note when iterating through site.collections as you may need to filter it out. You may wish to use filters to find your collection: {{ site.collections | where: "label", "myCollection" | first }}   Collections and Time Except for documents in hard-coded default collection posts, all documents in collections you create, are accessible via Liquid irrespective of their assigned date, if any, and therefore renderable.  Documents are attempted to be written to disk only if the concerned collection metadata has output: true. Additionally, future-dated documents are only written if site.future is also true.  More fine-grained control over documents being written to disk can be exercised by setting published: false (true by default) in the document's front matter.   Documents In addition to any front matter provided in the documentâ€™s corresponding file, each document has the following attributes:     Variable Description      content    The (unrendered) content of the document. If no front matter is provided, Jekyll will not generate the file in your collection. If front matter is used, then this is all the contents of the file after the terminating `---` of the front matter.      output    The rendered output of the document, based on the content.      path    The full path to the document's source file.      relative_path    The path to the document's source file relative to the site source.      url    The URL of the rendered collection. The file is only written to the destination when the collection to which it belongs has output: true in the site's configuration.      collection    The name of the document's collection.      date    The date of the document's collection.      
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/collections/


community/bug/index
-----------------------------------------------------------
Report a bug If you think youâ€™ve found a bug within a Jekyll plugin, open an issue in that pluginâ€™s repository â€” First look for the plugin on rubygems then click on the Homepage link to access the plugin repository. If you think youâ€™ve found a bug within Jekyll itself, open an issue.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/community/bug/


community/index
-----------------------------------------------------------
Community Jekyll Contributor Code of Conduct As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. Read the full code of conduct Where to get support If youâ€™re looking for support for Jekyll, there are a lot of options:  Read the Jekyll Documentation
 If you have a question about using Jekyll, start a discussion on the Jekyll Forum or StackOverflow
 Chat with Jekyllers â€” Join our Gitter channel or our IRC channel on Freenode
  There are a bunch of helpful community members on these services who are willing to point you in the right direction. Reminder: Jekyllâ€™s issue tracker is not a support forum. Ways to contribute  How to Contribute How to file a bug Guide for maintaining Jekyll  Jekyllconf Watch videos from members of the Jekyll community speak about interesting use cases, tricks theyâ€™ve learned or meta Jekyll topics. Jekyll on Twitter The official Jekyll Twitter account.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/community/


configuration/default/index
-----------------------------------------------------------
Default Configuration Jekyll runs with the following configuration options by default. Alternative settings for these options can be explicitly specified in the configuration file or on the command-line.  Be aware of directory paths  Make directory path values in configuration keys like `plugins_dir` relative to the current working directory, not the site source.   # Where things are
source              : .
destination         : ./_site
collections_dir     : .
plugins_dir         : _plugins # takes an array of strings and loads plugins in that order
layouts_dir         : _layouts
data_dir            : _data
includes_dir        : _includes
sass:
  sass_dir: _sass
collections:
  posts:
    output          : true
# Handling Reading
safe                : false
include             : [".htaccess"]
exclude             : ["Gemfile", "Gemfile.lock", "node_modules", "vendor/bundle/", "vendor/cache/", "vendor/gems/", "vendor/ruby/"]
keep_files          : [".git", ".svn"]
encoding            : "utf-8"
markdown_ext        : "markdown,mkdown,mkdn,mkd,md"
strict_front_matter : false
# Filtering Content
show_drafts         : null
limit_posts         : 0
future              : false
unpublished         : false
# Plugins
whitelist           : []
plugins             : []
# Conversion
markdown            : kramdown
highlighter         : rouge
lsi                 : false
excerpt_separator   : "
"
incremental         : false
# Serving
detach              : false
port                : 4000
host                : 127.0.0.1
baseurl             : "" # does not include hostname
show_dir_listing    : false
# Outputting
permalink           : date
paginate_path       : /page:num
timezone            : null
quiet               : false
verbose             : false
defaults            : []
liquid:
  error_mode        : warn
  strict_filters    : false
  strict_variables  : false
# Markdown Processors
kramdown:
  auto_ids          : true
  entity_output     : as_char
  toc_levels        : [1, 2, 3, 4, 5, 6]
  smart_quotes      : lsquo,rsquo,ldquo,rdquo
  input             : GFM
  hard_wrap         : false
  footnote_nr       : 1
  show_warnings     : false

    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/configuration/default/


configuration/environments/index
-----------------------------------------------------------
Environments In the build (or serve) arguments, you can specify a Jekyll environment and value. The build will then apply this value in any conditional statements in your content. For example, suppose you set this conditional statement in your code: {% if jekyll.environment == "production" %}
   {% include disqus.html %}
{% endif %}
 When you build your Jekyll site, the content inside the if statement wonâ€™t be run unless you also specify a production environment in the build command, like this: JEKYLL_ENV=production jekyll build
 Specifying an environment value allows you to make certain content available only within specific environments. The default value for JEKYLL_ENV is development. Therefore if you omit JEKYLL_ENV from the build arguments, the default value will be JEKYLL_ENV=development. Any content inside {% if jekyll.environment == "development" %} tags will automatically appear in the build. Your environment values can be anything you want (not just development or production). Some elements you might want to hide in development environments include Disqus comment forms or Google Analytics. Conversely, you might want to expose an â€œEdit me in GitHubâ€ button in a development environment but not include it in production environments. By specifying the option in the build command, you avoid having to change values in your configuration files when moving from one environment to another. To switch part of your config settings depending on the environment, use the build command option, for example --config _config.yml,_config_development.yml. Settings in later files override settings in earlier files.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/configuration/environments/


configuration/front-matter-defaults/index
-----------------------------------------------------------
Front Matter Defaults Using front matter is one way that you can specify configuration in the pages and posts for your site. Setting things like a default layout, or customizing the title, or specifying a more precise date/time for the post can all be added to your page or post front matter. Often times, you will find that you are repeating a lot of configuration options. Setting the same layout in each file, adding the same category - or categories - to a post, etc. You can even add custom variables like author names, which might be the same for the majority of posts on your blog. Instead of repeating this configuration each time you create a new post or page, Jekyll provides a way to set these defaults in the site configuration. To do this, you can specify site-wide defaults using the defaults key in the _config.yml file in your projectâ€™s root directory. The defaults key holds an array of scope/values pairs that define what defaults should be set for a particular file path, and optionally, a file type in that path. Letâ€™s say that you want to add a default layout to all pages and posts in your site. You would add this to your _config.yml file: defaults:
  -
    scope:
      path: "" # an empty string here means all files in the project
    values:
      layout: "default"
  Stop and rerun `jekyll serve` command.  The _config.yml master configuration file contains global configurations and variable definitions that are read once at execution time. Changes made to _config.yml during automatic regeneration are not loaded until the next execution.   Note Data Files are included and reloaded during automatic regeneration.   Here, we are scoping the values to any file that exists in the path scope. Since the path is set as an empty string, it will apply to all files in your project. You probably donâ€™t want to set a layout on every file in your project - like css files, for example - so you can also specify a type value under the scope key. defaults:
  -
    scope:
      path: "" # an empty string here means all files in the project
      type: "posts" # previously `post` in Jekyll 2.2.
    values:
      layout: "default"
 Now, this will only set the layout for files where the type is posts. The different types that are available to you are pages, posts, drafts or any collection in your site. While type is optional, you must specify a value for path when creating a scope/values pair. As mentioned earlier, you can set multiple scope/values pairs for defaults. defaults:
  -
    scope:
      path: ""
      type: "pages"
    values:
      layout: "my-site"
  -
    scope:
      path: "projects"
      type: "pages" # previously `page` in Jekyll 2.2.
    values:
      layout: "project" # overrides previous default layout
      author: "Mr. Hyde"
 With these defaults, all pages would use the my-site layout. Any html files that exist in the projects/ folder will use the project layout, if it exists. Those files will also have the page.author liquid variable set to Mr. Hyde. collections:
  my_collection:
    output: true
defaults:
  -
    scope:
      path: ""
      type: "my_collection" # a collection in your site, in plural form
    values:
      layout: "default"
 In this example, the layout is set to default inside the collection with the name my_collection. Glob patterns in Front Matter defaults It is also possible to use glob patterns (currently limited to patterns that contain *) when matching defaults. For example, it is possible to set specific layout for each special-page.html in any subfolder of section folder.3.7.0 collections:
  my_collection:
    output: true
defaults:
  -
    scope:
      path: "section/*/special-page.html"
    values:
      layout: "specific-layout"
  Globbing and Performance  Please note that globbing a path is known to have a negative effect on performance and is currently not optimized, especially on Windows. Globbing a path will increase your build times in proportion to the size of the associated collection directory.   Precedence Jekyll will apply all of the configuration settings you specify in the defaults section of your _config.yml file. You can choose to override settings from other scope/values pair by specifying a more specific path for the scope. You can see that in the second to last example above. First, we set the default page layout to my-site. Then, using a more specific path, we set the default layout for pages in the projects/ path to project. This can be done with any value that you would set in the page or post front matter. Finally, if you set defaults in the site configuration by adding a defaults section to your _config.yml file, you can override those settings in a post or page file. All you need to do is specify the settings in the post or page front matter. For example: # In _config.yml
...
defaults:
  -
    scope:
      path: "projects"
      type: "pages"
    values:
      layout: "project"
      author: "Mr. Hyde"
      category: "project"
...
 # In projects/foo_project.md
---
author: "John Smith"
layout: "foobar"
---
The post text goes here...
 The projects/foo_project.md would have the layout set to foobar instead of project and the author set to John Smith instead of Mr. Hyde when the site is built.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/configuration/front-matter-defaults/


configuration/incremental-regeneration/index
-----------------------------------------------------------
Default Configuration Incremental Regeneration  Incremental regeneration is still an experimental feature  While incremental regeneration will work for the most common cases, it will not work correctly in every scenario. Please be extremely cautious when using the feature, and report any problems not listed below by opening an issue on GitHub.   Incremental regeneration helps shorten build times by only generating documents and pages that were updated since the previous build. It does this by keeping track of both file modification times and inter-document dependencies in the .jekyll-metadata file. Under the current implementation, incremental regeneration will only generate a document or page if either it, or one of its dependencies, is modified. Currently, the only types of dependencies tracked are includes (using the {% include %} tag) and layouts. This means that plain references to other documents (for example, the common case of iterating over site.posts in a post listings page) will not be detected as a dependency. To remedy some of these shortfalls, putting regenerate: true in the front-matter of a document will force Jekyll to regenerate it regardless of whether it has been modified. Note that this will generate the specified document only; references to other documentsâ€™ contents will not work since they wonâ€™t be re-rendered. Incremental regeneration can be enabled via the --incremental flag (-I for short) from the command-line or by setting incremental: true in your configuration file.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/configuration/incremental-regeneration/


configuration/index
-----------------------------------------------------------
Configuration Jekyll gives you a lot of flexibility to customize how it builds your site. These options can either be specified in a _config.yml or _config.toml file placed in your siteâ€™s root directory, or can be specified as flags for the jekyll executable in the terminal.  Configuration Options Default Configuration Front Matter Defaults Environments Markdown Options Liquid Options Webrick Options Incremental Regeneration 
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/configuration/


configuration/liquid/index
-----------------------------------------------------------
Liquid Options Liquidâ€™s response to errors can be configured by setting error_mode. The options are  
lax â€” Ignore all errors. 
warn â€” Output a warning on the console for each error. (default) 
strict â€” Output an error message and stop the build.  Within _config.yml, the default configuration is as follows: liquid:
  error_mode: warn
 The above example depicts the â€œwarnâ€ value, which is already set by default- error_mode: warn. This results in any issues being called out during the build process however will continue to build if possible. You can also configure Liquidâ€™s renderer to catch non-assigned variables and non-existing filters by setting strict_variables and / or strict_filters to true respectively. 3.8.0 Do note that while error_mode configures Liquidâ€™s parser, the strict_variables and strict_filters options configure Liquidâ€™s renderer and are consequently, mutually exclusive. An example of setting these variables within _config.yml is as follows: liquid:
  error_mode: strict
  strict_variables: true
  strict_filters: true
 Configuring as described above will stop your build/serve from happening and call out the offending error and halt. This is helpful when desiring to catch liquid-related issues by stopping the build or serve process and allowing you to deal with any issues.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/configuration/liquid/


configuration/markdown/index
-----------------------------------------------------------
Markdown Options The various Markdown renderers supported by Jekyll sometimes have extra options available. Kramdown Kramdown is the default Markdown renderer for Jekyll. Below is a list of the currently supported options:   auto_id_prefix - Prefix used for automatically generated header IDs  auto_id_stripping - Strip all formatting from header text for automatic ID generation  auto_ids - Use automatic header ID generation  coderay_bold_every - Defines how often a line number should be made bold  coderay_css - Defines how the highlighted code gets styled  coderay_default_lang - Sets the default language for highlighting code blocks  coderay_line_number_start - The start value for the line numbers  coderay_line_numbers - Defines how and if line numbers should be shown  coderay_tab_width - The tab width used in highlighted code  coderay_wrap - Defines how the highlighted code should be wrapped  enable_coderay - Use coderay for syntax highlighting  entity_output - Defines how entities are output  footnote_backlink - Defines the text that should be used for the footnote backlinks  footnote_backlink_inline - Specifies whether the footnote backlink should always be inline  footnote_nr - The number of the first footnote  gfm_quirks - Enables a set of GFM specific quirks  hard_wrap - Interprets line breaks literally  header_offset - Sets the output offset for headers  html_to_native - Convert HTML elements to native elements  line_width - Defines the line width to be used when outputting a document  link_defs - Pre-defines link definitions  math_engine - Set the math engine  math_engine_opts - Set the math engine options  parse_block_html - Process kramdown syntax in block HTML tags  parse_span_html - Process kramdown syntax in span HTML tags  smart_quotes - Defines the HTML entity names or code points for smart quote output  syntax_highlighter - Set the syntax highlighter  syntax_highlighter_opts - Set the syntax highlighter options  toc_levels - Defines the levels that are used for the table of contents  transliterated_header_ids - Transliterate the header text before generating the ID  typographic_symbols - Defines a mapping from typographical symbol to output characters  Example Usage kramdown:
  html_to_native: true
  There are two unsupported kramdown options  Please note that both remove_block_html_tags and remove_span_html_tags are currently unsupported in Jekyll due to the fact that they are not included within the kramdown HTML converter.   For more details about these options have a look at the Kramdown configuration documentation. CommonMark CommonMark is a rationalized version of Markdown syntax, implemented in C and thus faster than default Kramdown implemented in Ruby. It slightly differs from original Markdown and does not support all the syntax elements implemented in Kramdown, like Block Inline Attribute Lists. It comes in two flavors: basic CommonMark with jekyll-commonmark plugin and GitHub Flavored Markdown supported by GitHub Pages. Custom Markdown Processors If youâ€™re interested in creating a custom markdown processor, youâ€™re in luck! Create a new class in the Jekyll::Converters::Markdown namespace: class Jekyll::Converters::Markdown::MyCustomProcessor
  def initialize(config)
    require 'funky_markdown'
    @config = config
  rescue LoadError
    STDERR.puts 'You are missing a library required for Markdown. Please run:'
    STDERR.puts '  $ [sudo] gem install funky_markdown'
    raise FatalException.new("Missing dependency: funky_markdown")
  end
  def convert(content)
    ::FunkyMarkdown.new(content).convert
  end
end
 Once youâ€™ve created your class and have it properly set up either as a plugin in the _plugins folder or as a gem, specify it in your _config.yml: markdown: MyCustomProcessor

    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/configuration/markdown/


configuration/options/index
-----------------------------------------------------------
Configuration Options The tables below list the available settings for Jekyll, and the various options (specified in the configuration file) and flags (specified on the command-line) that control them. Global Configuration     Setting  Options and Flags        Site Source  Change the directory where Jekyll will read files   source: DIR -s, --source DIR      Site Destination  Change the directory where Jekyll will write files   destination: DIR -d, --destination DIR      Safe  Disable non-whitelisted plugins, caching to disk, and ignore symbolic links.   safe: BOOL --safe      Disable Disk Cache 4.1.0  Disable caching of content to disk in order to skip creating a .jekyll-cache or similar directory at the source to avoid interference with virtual environments and third-party directory watchers. Caching to disk is always disabled in safe mode.   disable_disk_cache: BOOL --disable-disk-cache      Ignore theme configuration 4.1.0  Jekyll 4.0 started allowing themes to bundle a _config.yml to simplify theme-onboarding for new users. In the unfortunate situation that importing a bundled theme configuration messes up the merged site-configuration, the user can configure Jekyll to not import the theme-config entirely.   ignore_theme_config: BOOL      Exclude  Exclude directories and/or files from the conversion. These exclusions are relative to the site's source directory and cannot be outside the source directory.   exclude: [DIR, FILE, ...]      Include  Force inclusion of directories and/or files in the conversion. .htaccess is a good example since dotfiles are excluded by default.   include: [DIR, FILE, ...]      Keep files  When clobbering the site destination, keep the selected files. Useful for files that are not generated by jekyll; e.g. files or assets that are generated by your build tool. The paths are relative to the destination.   keep_files: [DIR, FILE, ...]      Time Zone  Set the time zone for site generation. This sets the TZ environment variable, which Ruby uses to handle time and date creation and manipulation. Any entry from the IANA Time Zone Database is valid, e.g. America/New_York. A list of all available values can be found  here. When serving on a local machine, the default time zone is set by your operating system. But when served on a remote host/server, the default time zone depends on the server's setting or location.   timezone: TIMEZONE      Encoding  Set the encoding of files by name (only available for Ruby 1.9 or later). The default value is utf-8 starting in 2.0.0, and nil before 2.0.0, which will yield the Ruby default of ASCII-8BIT. Available encodings can be shown by the command ruby -e 'puts Encoding::list.join("
")'.   encoding: ENCODING     Defaults  Set defaults for front matter variables.    see below       Destination folders are cleaned on site builds  The contents of <destination> are automatically cleaned, by default, when the site is built. Files or folders that are not created by your site will be removed. Some files could be retained by specifying them within the <keep_files> configuration directive.   Do not use an important location for <destination>; instead, use it as a staging area and copy files from there to your web server.   Build Command Options     Setting 
Options and Flags
       Regeneration  Enable auto-regeneration of the site when files are modified.   -w, --[no-]watch      Configuration  Specify config files instead of using _config.yml automatically. Settings in later files override settings in earlier files.   --config FILE1[,FILE2,...]      Plugins  Specify plugin directories instead of using _plugins/ automatically.   plugins_dir: [ DIR1,... ] -p, --plugins DIR1[,DIR2,...]      Layouts  Specify layout directory instead of using _layouts/ automatically.   layout_dir: DIR --layouts DIR      Drafts  Process and render draft posts.   show_drafts: BOOL -D, --drafts      Environment  Use a specific environment value in the build.   JEKYLL_ENV=production      Future  Publish posts or collection documents with a future date.   future: BOOL --future      Unpublished  Render posts that were marked as unpublished.   unpublished: BOOL --unpublished      LSI  Produce an index for related posts. Requires the classifier-reborn plugin.   lsi: BOOL --lsi      Limit Posts  Limit the number of posts to parse and publish.   limit_posts: NUM --limit_posts NUM      Force polling  Force watch to use polling.   force_polling: BOOL --force_polling      Verbose output  Print verbose output.   -V, --verbose      Silence Output  Silence the normal output from Jekyll during a build.   -q, --quiet      Incremental build  Enable the experimental incremental build feature. Incremental build only re-builds posts and pages that have changed, resulting in significant performance improvements for large sites, but may also break site generation in certain cases.   incremental: BOOL -I, --incremental      Liquid profiler  Generate a Liquid rendering profile to help you identify performance bottlenecks.   profile: BOOL --profile      Strict Front Matter  Cause a build to fail if there is a YAML syntax error in a page's front matter.   strict_front_matter: BOOL --strict_front_matter      Base URL  Serve the website from the given base URL.   baseurl: URL -b, --baseurl URL      Trace  Show the full backtrace when an error occurs.   -t, --trace      Serve Command Options In addition to the options below, the serve sub-command can accept any of the options for the build sub-command, which are then applied to the site build which occurs right before your site is served.     Setting 
Options and Flags
       Local Server Port  Listen on the given port.   port: PORT -P, --port PORT      Local Server Hostname  Listen at the given hostname.   host: HOSTNAME -H, --host HOSTNAME      Live Reload  Reload a page automatically on the browser when its content is edited.   livereload: BOOL -l, --livereload      Live Reload Ignore  File glob patterns for LiveReload to ignore.   livereload_ignore: [ GLOB1,... ] --livereload-ignore GLOB1[,GLOB2,...]      Live Reload Min/Max Delay  Minimum/Maximum delay before automatically reloading page.    livereload_min_delay: SECONDS livereload_max_delay: SECONDS   --livereload-min-delay SECONDS --livereload-max-delay SECONDS       Live Reload Port  Port for LiveReload to listen on.   --livereload-port PORT      Open URL  Open the site's URL in the browser.   open_url: BOOL -o, --open-url      Detach  Detach the server from the terminal.   detach: BOOL -B, --detach      Skips the initial site build  Skips the initial site build which occurs before the server is started.   skip_initial_build: BOOL --skip-initial-build      Show Directory Listing  Show a directory listing instead of loading your index file.   show_dir_listing: BOOL --show-dir-listing      X.509 (SSL) Private Key  SSL Private Key, stored or symlinked in the site source.   --ssl-key      X.509 (SSL) Certificate  SSL Public certificate, stored or symlinked in the site source.   --ssl-cert       Do not use tabs in configuration files  This will either lead to parsing errors, or Jekyll will revert to the default settings. Use spaces instead.  
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/configuration/options/


configuration/webrick/index
-----------------------------------------------------------
WEBrick Options You can provide custom headers for your site by adding them to _config.yml # File: _config.yml
webrick:
  headers:
    My-Header: My-Value
    My-Other-Header: My-Other-Value
 Defaults Jekyll provides by default Content-Type and Cache-Control response headers: one dynamic in order to specify the nature of the data being served, the other static in order to disable caching so that you donâ€™t have to fight with Chromeâ€™s aggressive caching when you are in development mode.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/configuration/webrick/


continuous-integration/buddyworks/index
-----------------------------------------------------------
Buddy Buddy is a Docker-based CI server that you can set up in 15-20 minutes to build, test, and deploy your Jekyll websites. It supports GitHub, Bitbucket, and GitLab repositories, and can be installed on-premises or used in cloud. The following guide will show you how to set up a free environment to build and test your Jekyll project. 1. Getting started  Log in at https://buddy.works with your GitHub/Bitbucket account or email Choose your Git provider and select or push your Jekyll Project Create a new pipeline and set the trigger mode to â€˜On every pushâ€™ Add and configure the Jekyll action and save the pipeline  2. How it works Whenever you make a push to the selected branch, the Jekyll action runs jekyll build in an isolated Jekyll Docker image. The output is generated to the /filesystem directory, and can be further deployed to FTP/SFTP and IaaS services. You can add your own commands, install additional packages, attach services, and run Selenium tests, as well as add other actions down the pipeline, eg. a Slack notification or an SSH script that will restart your server. 3. Using YAML for configuration If you prefer configuration as code over GUI, you can generate a buddy.yml that will create a pipeline with the Jekyll action once you push it to the target branch: - pipeline: "Build and Deploy Jekyll site"
  trigger_mode: "ON_EVERY_PUSH"
  ref_name: "master"
  actions:
  - action: "Execute: jekyll build"
    type: "BUILD"
    docker_image_name: "jekyll/jekyll"
    docker_image_tag: "latest"
    execute_commands:
    - "chown jekyll:jekyll $WORKING_DIR"
    - "jekyll build"
 4. Setting up on-premises server The self-hosted version of Buddy can be installed on any type of server supporting Docker, including Linux, Mac, AWS EC2, DigitalOcean, and Microsoft Azure. 5. Questions? This entire guide is open-source. Go ahead and edit it if you want to expand it or have a fix or ask for help if you run into trouble and need assistance. Buddy also has an online community for help.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/continuous-integration/buddyworks/


continuous-integration/circleci/index
-----------------------------------------------------------
CircleCI Building, testing, and deploying your Jekyll-generated website can quickly be done with CircleCI, a continuous integration & delivery tool. CircleCI supports GitHub and Bitbucket, and you can get started for free using an open-source or private repository. 1. Follow Your Project on CircleCI To start building your project on CircleCI, all you need to do is â€˜followâ€™ your project from CircleCIâ€™s website:  Visit the â€˜Add Projectsâ€™ page From the GitHub or Bitbucket tab on the left, choose a user or organization. Find your project in the list and click â€˜Build projectâ€™ on the right. The first build will start on its own. You can start telling CircleCI how to build your project by creating a circle.yml file in the root of your repository.  2. Dependencies The easiest way to manage dependencies for a Jekyll project (with or without CircleCI) is via a Gemfile. Youâ€™d want to have Jekyll, any Jekyll plugins, HTML Proofer, and any other gems that you are using in the Gemfile. Donâ€™t forget to version Gemfile.lock as well. Hereâ€™s an example Gemfile: source 'https://rubygems.org'
ruby '2.4.0'
gem 'jekyll'
gem 'html-proofer'
 CircleCI detects when Gemfile is present and will automatically run bundle install for you in the dependencies phase. 3. Testing The most basic test that can be run is seeing if jekyll build actually works. This is a blocker, a dependency if you will, for other tests you might run on the generate site. So weâ€™ll run Jekyll, via Bundler, in the dependencies phase. dependencies:
  post:
    - bundle exec jekyll build
 HTML Proofer With your site built, itâ€™s useful to run tests to check for valid HTML, broken links, etc. Thereâ€™s a few tools out there but HTML Proofer is popular amongst Jekyll users. Weâ€™ll run it in the test phase with a few preferred flags. Check out the html-proofer README for all available flags, or run htmlproofer --help locally. test:
  post:
    - bundle exec htmlproofer ./_site --check-html --disable-external
 Complete Example circle.yml File Since v2, CircleCI is a Docker-based system. The example circle.yml below demonstrates how to deploy your Jekyll project to AWS. In order for this to work you would first have to set the S3_BUCKET_NAME environment variable. defaults: &defaults
  working_directory: ~/repo
version: 2
jobs:
  build:
    <<: *defaults
    docker:
      - image: circleci/ruby:2.5
    environment:
      BUNDLE_PATH: ~/repo/vendor/bundle
    steps:
      - checkout
      - restore_cache:
          keys:
            - rubygems-v1-{{ checksum "Gemfile.lock" }}
            - rubygems-v1-fallback
      - run:
          name: Bundle Install
          command: bundle check || bundle install
      - save_cache:
          key: rubygems-v1-{{ checksum "Gemfile.lock" }}
          paths:
            - vendor/bundle
      - run:
          name: Jekyll build
          command: bundle exec jekyll build
      - run:
          name: HTMLProofer tests
          command: |
            bundle exec htmlproofer ./_site \
              --allow-hash-href \
              --check-favicon  \
              --check-html \
              --disable-external
      - persist_to_workspace:
          root: ./
          paths:
            - _site
  deploy:
    <<: *defaults
    docker:
      - image: circleci/python:3.6.3
    environment:
      S3_BUCKET_NAME: <<YOUR BUCKET NAME HERE>>
    steps:
      - attach_workspace:
          at: ./
      - run:
          name: Install AWS CLI
          command: pip install awscli --upgrade --user
      - run:
          name: Upload to s3
          command: ~/.local/bin/aws s3 sync ./_site s3://$S3_BUCKET_NAME/ --delete --acl public-read
workflows:
  version: 2
  test-deploy:
    jobs:
      - build
      - deploy:
          requires:
            - build
          filters:
            branches:
              only: master
 Questions? This entire guide is open-source. Go ahead and edit it if you have a fix or ask for help if you run into trouble and need some help. CircleCI also has an online community for help.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/continuous-integration/circleci/


continuous-integration/github-actions/index
-----------------------------------------------------------
GitHub Actions When building a Jekyll site with GitHub Pages, the standard flow is restricted for security reasons and to make it simpler to get a site setup. For more control over the build and still host the site with GitHub Pages you can use GitHub Actions. Advantages of using Actions Control over gemset  
Jekyll version â€” Instead of using the currently enabled version at 3.9.0, you can use any version of Jekyll you want. For example 4.0.0, or point directly to the repository. 
Plugins â€” You can use any Jekyll plugins irrespective of them being on the supported versions list, even *.rb files placed in the _plugins directory of your site. 
Themes â€” While using a custom theme is possible without Actions, it is now simpler.  Workflow Management  
Customization â€” By creating a workflow file to run Actions, you can specify custom build steps, use environment variables. 
Logging â€” The build log is visible and can be tweaked to be verbose, so it is much easier to debug errors using Actions.  Workspace setup The first and foremost requirement is a Jekyll project hosted at GitHub. Choose an existing Jekyll project or follow the Quickstart and push the repository to GitHub if it is not hosted there already. Weâ€™re only going to cover builds from the master branch in this page. Therefore, ensure that you are working on the master branch. If necessary, you may create it based on your default branch. When the Action builds your site, the contents of the destination directory will be automatically pushed to the gh-pages branch with a commit, ready to be used for serving. The Action weâ€™re using here will create (or reset an existing) gh-pages branch on every successful deploy. So, if you have an existing gh-pages branch that is used to deploy your production build, ensure to make a backup of the contents into a different branch so that you can rollback easily if necessary. The Jekyll site weâ€™ll be using for the rest of this page initially consists of just a _config.yml, an index.md page and a Gemfile. The contents are respectively: # _config.yml
title: "Jekyll Actions Demo"
 ---
---
Welcome to My Home Page
{% assign date = '2020-04-13T10:20:00Z' %}
- Original date - {{ date }}
- With timeago filter - {{ date | timeago }}
 # Gemfile
source 'https://rubygems.org'
gem 'jekyll', '~> 4.0'
group :jekyll_plugins do
  gem 'jekyll-timeago', '~> 0.13.1'
end
 The demo site uses Jekyll 4 and a third-party plugin, both of which are currently not whitelisted for use on GitHub pages. The plugin will allow us to describe how far back a date was from today. e.g. If we give a date as 2016-03-23T10:20:00Z and the current date is 2020-04-13T10:20:00Z, then the output would be 4 years and 3 weeks ago. The action weâ€™re using takes care of installing the Ruby gems and dependencies. While that keeps the setup simple for the user, one may encounter issues if they also check-in Gemfile.lock if it was generated with an old version of Bundler. Setting up the Action GitHub Actions are registered for a repository by using a YAML file inside the directory path .github/workflows (note the dot at the start). Here we shall employ Jekyll Actions from the Marketplace for its simplicity. Create a workflow file, say github-pages.yml, using either the GitHub interface or by pushing a YAML file to the workflow directory path manually. The base contents are: name: Build and deploy Jekyll site to GitHub Pages
on:
  push:
    branches:
      - master
jobs:
  github-pages:
    runs-on: ubuntu-16.04
    steps:
      - uses: actions/checkout@v2
      - uses: helaili/jekyll-action@2.0.1
        env:
          JEKYLL_PAT: ${{ secrets.JEKYLL_PAT }}
 The above workflow can be explained as the following:  We trigger the build using on.push condition for master branch only â€” this prevents the Action from overwriting the gh-pages branch on any feature branch pushes. The name of the job matches our YAML filename: github-pages. The checkout action takes care of cloning your repository. We specify our selected action and version number using helaili/jekyll-action@2.0.0. This handles the build and deploy. We set a reference to a secret environment variable for the action to use. The JEKYLL_PAT is a Personal Access Token and is detailed in the next section.  Instead of using the on.push condition, you could trigger your build on a schedule by using the on.schedule parameter. For example, here we build daily at midnight by specifying cron syntax, which can be tested at the crontab guru site. on:
  schedule:
    - cron:  '0 0 * * *'
 Note that this string must be quoted to prevent the asterisks from being evaluated incorrectly. Providing permissions The action needs permissions to push to your gh-pages branch. So you need to create a GitHub authentication token on your GitHub profile, then set it as an environment variable in your build using Secrets:  On your GitHub profile, under Developer Settings, go to the Personal Access Tokens section. 
Create a token. Give it a name like â€œGitHub Actionsâ€ and ensure it has permissions to public_repos (or the entire repo scope for private repository) â€” necessary for the action to commit to the gh-pages branch. 
Copy the token value. Go to your repositoryâ€™s Settings and then the Secrets tab. 
Create a token named JEKYLL_PAT (important). Give it a value using the value copied above.  Build and deploy On pushing any local changes onto master, the action will be triggered and the build will start. To watch the progress and see any build errors, check on the build status using one of the following approaches:  
View by commit  Go to the repository level view in GitHub. Under the most recent commit (near the top) youâ€™ll see a status symbol next to the commit message as a tick or X. Hover over it and click the details link.   
Actions tab  Go to the repositoryâ€™s Actions tab. Click on the jekyll workflow tab.    If all goes well, all steps will be green and the built assets will now exist on the gh-pages branch. On a successful build, GitHub Pages will publish the site stored on the repository gh-pages branches. Note that you do not need to setup a gh-pages branch or enable GitHub Pages, as the action will take care of this for you. (For private repositories, youâ€™ll have to upgrade to a paid plan). To see the live site:  Go to the environment tab on your repository. Click View Deployment to see the deployed site URL. View your site at the URL. Make sure the timeago filter works as expected. Optionally add this URL to your repositoryâ€™s main page and to your README.md, to make it easy for people to find.  When you need to make further changes to the site, commit to master and push. The workflow will build and deploy your site again. Be sure not to edit the gh-pages branch directly, as any changes will be lost on the next successful deploy from the Action. External links  
jekyll-actions is an action available on the GitHub Marketplace and was used in this guide. 
jekyll-actions-quickstart is an unofficial repository that includes a live demo of the jekyll-actions action. That project can be used as a template for making a new site. 
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/continuous-integration/github-actions/


continuous-integration/travis-ci/index
-----------------------------------------------------------
Travis CI You can test your website build against one or more versions of Ruby. The following guide will show you how to set up a free build environment on Travis, with GitHub integration for pull requests. 1. Enabling Travis and GitHub To enable Travis builds for your GitHub repository:  Go to your profile on travis-ci.org: https://travis-ci.org/profile/username Find the repository for which youâ€™re interested in enabling builds. Flick the repository switch on so that it turns blue. Optionally configure the build by clicking on the gear icon. Further configuration happens via your .travis.yml file. More details below.  2. The Test Script The simplest test script runs jekyll build and ensures that Jekyll doesnâ€™t fail to build the site. It doesnâ€™t check the resulting site, but it does ensure things are built properly. When testing Jekyll output, there is no better tool than html-proofer. This tool checks your resulting site to ensure all links and images exist. Utilize it either with the convenient htmlproofer command-line executable, or write a Ruby script which utilizes the gem. Save the commands you want to run and succeed in a file: ./script/cibuild The HTML Proofer Executable #!/usr/bin/env bash
set -e # halt script on error
bundle exec jekyll build
bundle exec htmlproofer ./_site
 Some options can be specified via command-line switches. Check out the html-proofer README for more information about these switches, or run htmlproofer --help locally. For example to avoid testing external sites, use this command: bundle exec htmlproofer ./_site --disable-external
 The HTML Proofer Library You can also invoke html-proofer in Ruby scripts (e.g. in a Rakefile): #!/usr/bin/env ruby
require 'html-proofer'
HTMLProofer.check_directory("./_site").run
 Options are given as a second argument to .new, and are encoded in a symbol-keyed Ruby Hash. For more information about the configuration options, check out html-prooferâ€™s README file. 3. Configuring Your Travis Builds This file is used to configure your Travis builds. Because Jekyll is built with Ruby and requires RubyGems to install, we use the Ruby language build environment. Below is a sample .travis.yml file, followed by an explanation of each line. Note: You will need a Gemfile as well, Travis will automatically install the dependencies based on the referenced gems. Here is an example Gemfile with two referenced gems, â€œjekyllâ€ and â€œhtml-prooferâ€: source "https://rubygems.org"
gem "jekyll"
gem "html-proofer"
 Your .travis.yml file should look like this: language: ruby
rvm:
  - 2.6.3
before_script:
 - chmod +x ./script/cibuild # or do this locally and commit
# Assume bundler is being used, therefore
# the `install` step will run `bundle install` by default.
script: ./script/cibuild
# branch whitelist, only for GitHub Pages
branches:
  only:
  - gh-pages     # test the gh-pages branch
  - /pages-(.*)/ # test every branch which starts with "pages-"
addons:
  apt:
    packages:
    - libcurl4-openssl-dev
cache: bundler # caching bundler gem packages will speed up build
# Optional: disable email notifications about the outcome of your builds
notifications:
  email: false
 Ok, now for an explanation of each line: language: ruby
 This line tells Travis to use a Ruby build container. It gives your script access to Bundler, RubyGems, and a Ruby runtime. rvm:
  - 2.6.3
 RVM is a popular Ruby Version Manager (like rbenv, chruby, etc). This directive tells Travis the Ruby version to use when running your test script. Use a version which is pre-installed on the Travis build docker image to speed up the build. before_script:
 - chmod +x ./script/cibuild
 The build script file needs to have the executable attribute set or Travis will fail with a permission denied error. You can also run this locally and commit the permissions directly, thus rendering this step irrelevant. script: ./script/cibuild
 Travis allows you to run any arbitrary shell script to test your site. One convention is to put all scripts for your project in the script directory, and to call your test script cibuild. This line is completely customizable. If your script wonâ€™t change much, you can write your test incantation here directly: install: gem install jekyll html-proofer
script: jekyll build && htmlproofer ./_site
 The script directive can be absolutely any valid shell command. # branch whitelist, only for GitHub Pages
branches:
  only:
  - gh-pages     # test the gh-pages branch
  - /pages-(.*)/ # test every branch which starts with "pages-"
 You want to ensure the Travis builds for your site are being run only on the branch or branches which contain your site. One means of ensuring this isolation is including a branch whitelist in your Travis configuration file. By specifying the gh-pages branch, you will ensure the associated test script (discussed above) is only executed on site branches. If you use a pull request flow for proposing changes, you may wish to enforce a convention for your builds such that all branches containing edits are prefixed, exemplified above with the /pages-(.*)/ regular expression. The branches directive is completely optional. Travis will build from every push to any branch of your repo if leave it out.  Be sure to exclude vendor from your _config.yml
 Travis bundles all gems in the vendor directory on its build servers, which Jekyll will mistakenly read and explode on.  exclude: [vendor]
 To speed up the build, you should cache the gem packages created by bundler. Travis has a pre-defined cache strategy for this tool which should have all the default configs to do exactly that. cache: bundler
 Optionally, if you are not interested in the build email notifications you can disable them with this configuration. Travis supports a wide array of notification services, you may find another one more useful (e.g. slack). notifications:
  email: false
 Troubleshooting Travis error: â€œYou are trying to install in deployment mode after changing your Gemfile. Run bundle install elsewhere and add the updated Gemfile.lock to version control.â€ Workaround: Either run bundle install locally and commit your changes to Gemfile.lock, or remove the Gemfile.lock file from your repository and add an entry in the .gitignore file to avoid it from being checked in again. Questions? This entire guide is open-source. Go ahead and edit it if you have a fix or ask for help if you run into trouble and need some help.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/continuous-integration/travis-ci/


datafiles/index
-----------------------------------------------------------
Data Files In addition to the built-in variables available from Jekyll, you can specify your own custom data that can be accessed via the Liquid templating system. Jekyll supports loading data from YAML, JSON, CSV, and TSV files located in the _data directory. Note that CSV and TSV files must contain a header row. This powerful feature allows you to avoid repetition in your templates and to set site specific options without changing _config.yml. Plugins/themes can also leverage Data Files to set configuration variables. The Data Folder The _data folder is where you can store additional data for Jekyll to use when generating your site. These files must be YAML, JSON, or CSV files (using either the .yml, .yaml, .json or .csv extension), and they will be accessible via site.data. Example: List of members Here is a basic example of using Data Files to avoid copy-pasting large chunks of code in your Jekyll templates: In _data/members.yml: - name: Eric Mill
  github: konklone
- name: Parker Moore
  github: parkr
- name: Liu Fengyun
  github: liufengyun
 Or _data/members.csv: name,github
Eric Mill,konklone
Parker Moore,parkr
Liu Fengyun,liufengyun
 This data can be accessed via site.data.members (notice that the fileâ€™s basename determines the variable name and therefore one should avoid having data files with the same basename but different extensions, in the same directory). You can now render the list of members in a template: <ul>
{% for member in site.data.members %}
  <li>
    <a href="https://github.com/{{ member.github }}">
      {{ member.name }}
    </a>
  </li>
{% endfor %}
</ul>
 Subfolders Data files can also be placed in sub-folders of the _data folder. Each folder level will be added to a variableâ€™s namespace. The example below shows how GitHub organizations could be defined separately in a file under the orgs folder: In _data/orgs/jekyll.yml: username: jekyll
name: Jekyll
members:
  - name: Tom Preston-Werner
    github: mojombo
  - name: Parker Moore
    github: parkr
 In _data/orgs/doeorg.yml: username: doeorg
name: Doe Org
members:
  - name: John Doe
    github: jdoe
 The organizations can then be accessed via site.data.orgs, followed by the file name: <ul>
{% for org_hash in site.data.orgs %}
{% assign org = org_hash[1] %}
  <li>
    <a href="https://github.com/{{ org.username }}">
      {{ org.name }}
    </a>
    ({{ org.members | size }} members)
  </li>
{% endfor %}
</ul>
 Example: Accessing a specific author Pages and posts can also access a specific data item. The example below shows how to access a specific item: _data/people.yml: dave:
    name: David Smith
    twitter: DavidSilvaSmith
 The author can then be specified as a page variable in a postâ€™s front matter: ---
title: sample post
author: dave
---
{% assign author = site.data.people[page.author] %}
<a rel="author"
  href="https://twitter.com/{{ author.twitter }}"
  title="{{ author.name }}">
    {{ author.name }}
</a>
 For information on how to build robust navigation for your site (especially if you have a documentation website or another type of Jekyll site with a lot of pages to organize), see Navigation.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/datafiles/


deployment/automated/index
-----------------------------------------------------------
Automated Deployment There are a number of ways to easily automate the deployment of a Jekyll site. Continuous Integration Service One of the easiest ways to set up an automated deployment flow is by using a CI. These services run a script when thereâ€™s a commit on your Git repository. You might want this script to build the site, run tests over the output then deploy it to the service of your choice. We have guides for the following providers:  GitHub Actions Travis CI CircleCI Buddy  Git post-receive hook To have a remote server handle the deploy for you every time you push changes using Git, you can create a user account which has all the public keys that are authorized to deploy in its authorized_keys file. With that in place, setting up the post-receive hook is done as follows: laptop$ ssh deployer@example.com
server$ mkdir myrepo.git
server$ cd myrepo.git
server$ git --bare init
server$ cp hooks/post-receive.sample hooks/post-receive
server$ mkdir /var/www/myrepo
 Next, add the following lines to hooks/post-receive and be sure Jekyll is installed on the server: #!/bin/bash -l
# Install Ruby Gems to ~/gems
export GEM_HOME=$HOME/gems
export PATH=$GEM_HOME/bin:$PATH
TMP_GIT_CLONE=$HOME/tmp/myrepo
GEMFILE=$TMP_GIT_CLONE/Gemfile
PUBLIC_WWW=/var/www/myrepo
git clone $GIT_DIR $TMP_GIT_CLONE
BUNDLE_GEMFILE=$GEMFILE bundle install
BUNDLE_GEMFILE=$GEMFILE bundle exec jekyll build -s $TMP_GIT_CLONE -d $PUBLIC_WWW
rm -Rf $TMP_GIT_CLONE
exit
 Finally, run the following command on any users laptop that needs to be able to deploy using this hook: laptops$ git remote add deploy deployer@example.com:~/myrepo.git
 Deploying is now as easy as telling nginx or Apache to look at /var/www/myrepo and running the following: laptops$ git push deploy master

    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/deployment/automated/


deployment/index
-----------------------------------------------------------
Deployment Sites built using Jekyll can be deployed in a large number of ways due to the static nature of the generated output. Hereâ€™s some of the most common ways:  Manually Automated Third Party 
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/deployment/


deployment/manual/index
-----------------------------------------------------------
Manual Deployment Jekyll generates your static site to the _site directory by default. You can transfer the contents of this directory to almost any hosting provider to get your site live. Here are some manual ways of achieving this: rsync Rsync is similar to scp except it can be faster as it will only send changed parts of files as opposed to the entire file. You can learn more about using rsync in the Digital Ocean tutorial. Amazon S3 If you want to host your site in Amazon S3, you can do so by using the s3_website application. It will push your site to Amazon S3 where it can be served like any web server, dynamically scaling to almost unlimited traffic. This approach has the benefit of being about the cheapest hosting option available for low-volume blogs as you only pay for what you use. FTP Most traditional web hosting provider let you upload files to their servers over FTP. To upload a Jekyll site to a web host using FTP, run the jekyll build command and copy the contents of the generated _site folder to the root folder of your hosting account. This is most likely to be the httpdocs or public_html folder on most hosting providers. scp If you have direct access to the deployment web server, the process is essentially the same, except you might have other methods available to you (such as scp, or even direct filesystem access) for transferring the files. Remember to make sure the contents of the generated _site folder get placed in the appropriate web root directory for your web server. Rack-Jekyll Rack-Jekyll allows you to deploy your site on any Rack server such as Amazon EC2, Slicehost, Heroku, and so forth. It also can run with shotgun, rackup, mongrel, unicorn, and others.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/deployment/manual/


deployment/third-party/index
-----------------------------------------------------------
3rd Party Aerobatic Aerobatic has custom domains, global CDN distribution, basic auth, CORS proxying, and a growing list of plugins all included. Automating the deployment of a Jekyll site is simple. See their Jekyll docs for more details. Your built _site folder is deployed to their highly-available, globally distributed hosting service. AWS Amplify The AWS Amplify Console provides continuous deployment and hosting for modern web apps (single page apps and static site generators). Continuous deployment allows developers to deploy updates to their web app on every code commit to their Git repository. Hosting includes features such as globally available CDNs, 1-click custom domain setup + HTTPS, feature branch deployments, redirects, trailing slashes, and password protection. Read this step-by-step guide to deploy and host your Jekyll site on AWS Amplify. Bip Bip provides zero downtime deployment, a global CDN, SSL, unlimited bandwidth and more for Jekyll websites. Deploy in seconds from the command line. Visit the Bip website for more information - which is also built with Jekyll. CloudCannon CloudCannon has everything you need to build, host and update Jekyll websites. Take advantage of our global CDN, automated SSL, continuous deployment and more. GitHub Pages Sites on GitHub Pages are powered by Jekyll behind the scenes, so if youâ€™re looking for a zero-hassle, zero-cost solution, GitHub Pages are a great way to host your Jekyll-powered website for free. GitLab Pages GitLab Pages offers free hosting with custom domains. Get started with Jekyll and a fully customizable pipeline. KeyCDN KeyCDN accelerates Jekyll-powered websites with a wide range of other features such as real time image processing including WebP transformation. The Jekyll hosting tutorial provides various options to supercharge Jekyll sites with just a few steps. It combines best flexibility and excellent performance. Kickster Use Kickster for automated deploys to GitHub Pages when using unsupported plugins on GitHub Pages. Kickster provides a basic Jekyll project setup packed with web best practises and useful optimization tools increasing your overall project quality. Kickster ships with automated and worry-free deployment scripts for GitHub Pages. Install the Kickster gem and you are good to go. More documentation can here found here. If you do not want to use the gem or start a new project you can just copy paste the deployment scripts for Travis CI or Circle CI. Netlify Netlify provides Global CDN, Continuous Deployment, one click HTTPS and much more, providing developers a robust toolset for modern web projects, without added complexity. Netlify supports custom plugins for Jekyll and has a free plan for open source projects. Read this Jekyll step-by-step guide to setup your Jekyll site on Netlify. Render Render provides zero config continuous deployment for static sites. The service is free under 100GB monthly bandwith. Static Publisher Static Publisher is another automated deployment option with a server listening for webhook posts, though itâ€™s not tied to GitHub specifically. It has a one-click deploy to Heroku, it can watch multiple projects from one server, it has an easy to user admin interface and can publish to either S3 or to a git repository (e.g. gh-pages). Vercel Vercel provides zero config continuous deployment, HTTPS Custom domains, high performance smart CDN, you get instant static deploy for free. 21YunBox 21YunBox provides blazing fast Chinese CDN, Continuous Deployment, one click HTTPS and much more, providing developers a hassle-free solution to launch their web projects in China. Read this Jekyll step-by-step guide to deploy your Jekyll site on 21YunBox.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/deployment/third-party/


front-matter/index
-----------------------------------------------------------
Front Matter Any file that contains a YAML front matter block will be processed by Jekyll as a special file. The front matter must be the first thing in the file and must take the form of valid YAML set between triple-dashed lines. Here is a basic example: ---
layout: post
title: Blogging Like a Hacker
---
 Between these triple-dashed lines, you can set predefined variables (see below for a reference) or even create custom ones of your own. These variables will then be available for you to access using Liquid tags both further down in the file and also in any layouts or includes that the page or post in question relies on.  UTF-8 Character Encoding Warning  If you use UTF-8 encoding, make sure that no BOM header characters exist in your files or very, very bad things will happen to Jekyll. This is especially relevant if youâ€™re running Jekyll on Windows.    Front Matter Variables Are Optional  If you want to use Liquid tags and variables but donâ€™t need anything in your front matter, just leave it empty! The set of triple-dashed lines with nothing in between will still get Jekyll to process your file. (This is useful for things like CSS and RSS feeds!)   Predefined Global Variables There are a number of predefined global variables that you can set in the front matter of a page or post.     Variable Description      layout    If set, this specifies the layout file to use. Use the layout file name without the file extension. Layout files must be placed in the _layouts directory.    Using null will produce a file without using a layout file. This is overridden if the file is a post/document and has a layout defined in the  front matter defaults.   Starting from version 3.5.0, using none in a post/document will produce a file without using a layout file regardless of front matter defaults. Using none in a page will cause Jekyll to attempt to use a layout named "none".       permalink    If you need your processed blog post URLs to be something other than the site-wide style (default /year/month/day/title.html), then you can set this variable and it will be used as the final URL.      published    Set to false if you donâ€™t want a specific post to show up when the site is generated.        Render Posts Marked As Unpublished  To preview unpublished pages, run `jekyll serve` or `jekyll build` with the `--unpublished` switch. Jekyll also has a handy drafts feature tailored specifically for blog posts.   Custom Variables You can also set your own front matter variables you can access in Liquid. For instance, if you set a variable called food, you can use that in your page: ---
food: Pizza
---
<h1>{{ page.food }}</h1>
 Predefined Variables for Posts These are available out-of-the-box to be used in the front matter for a post.     Variable Description      date    A date here overrides the date from the name of the post. This can be used to ensure correct sorting of posts. A date is specified in the format YYYY-MM-DD HH:MM:SS +/-TTTT; hours, minutes, seconds, and timezone offset are optional.      category categories    Instead of placing posts inside of folders, you can specify one or more categories that the post belongs to. When the site is generated the post will act as though it had been set with these categories normally. Categories (plural key) can be specified as a YAML list or a space-separated string.      tags    Similar to categories, one or multiple tags can be added to a post. Also like categories, tags can be specified as a YAML list or a space-separated string.        Don't repeat yourself  If you don't want to repeat your frequently used front matter variables over and over, define defaults for them and only override them where necessary (or not at all). This works both for predefined and custom variables.  
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/front-matter/


github-pages/index
-----------------------------------------------------------
GitHub Pages GitHub Pages are public web pages for users, organizations, and repositories, that are freely hosted on GitHubâ€™s github.io domain or on a custom domain name of your choice. GitHub Pages are powered by Jekyll behind the scenes, so theyâ€™re a great way to host your Jekyll-powered website for free. Your site is automatically generated by GitHub Pages when you push your source files. Note that GitHub Pages works equally well for regular HTML content, simply because Jekyll treats files without front matter as static assets. So if you only need to push generated HTML, youâ€™re good to go without any further setup. Never built a website with GitHub Pages before? See this marvelous guide by Jonathan McGlone to get you up and running. This guide will teach you what you need to know about Git, GitHub, and Jekyll to create your very own website on GitHub Pages. The github-pages gem Our friends at GitHub have provided the github-pages gem which is used to manage Jekyll and its dependencies on GitHub Pages. Using it in your projects means that when you deploy your site to GitHub Pages, you will not be caught by unexpected differences between various versions of the gems. Note that GitHub Pages runs in safe mode and only allows a set of whitelisted plugins. To use the currently-deployed version of the gem in your project, add the following to your Gemfile: source "https://rubygems.org"
gem "github-pages", group: :jekyll_plugins
 Be sure to run bundle update often.  GitHub Pages Documentation, Help, and Support  For more information about what you can do with GitHub Pages, as well as for troubleshooting guides, you should check out GitHubâ€™s Pages Help section. If all else fails, you should contact GitHub Support.   Project Page URL Structure Sometimes itâ€™s nice to preview your Jekyll site before you push your gh-pages branch to GitHub. The subdirectory-like URL structure GitHub uses for Project Pages complicates the proper resolution of URLs. In order to assure your site builds properly, use the handy URL filters: <!-- For styles with static names... -->
<link href="{{ 'assets/css/style.css' | relative_url }}" rel="stylesheet">
<!-- For documents/pages whose URLs can change... -->
[{{ page.title }}]("{{ page.url | relative_url }}")
 This way you can preview your site locally from the site root on localhost, but when GitHub generates your pages from the gh-pages branch all the URLs will resolve properly. Deploying Jekyll to GitHub Pages GitHub Pages work by looking at certain branches of repositories on GitHub. There are two basic types available: user/organization and project pages. The way to deploy these two types of sites are nearly identical, except for a few minor details. User and Organization Pages User and organization pages live in a special GitHub repository dedicated to only the GitHub Pages files. This repository must be named after the account name. For example, @mojomboâ€™s user page repository has the name mojombo.github.io. Content from the master branch of your repository will be used to build and publish the GitHub Pages site, so make sure your Jekyll site is stored there.  Custom domains do not affect repository names  GitHub Pages are initially configured to live under the username.github.io subdomain, which is why repositories must be named this way even if a custom domain is being used.   Project Pages Unlike user and organization Pages, Project Pages are kept in the same repository as the project they are for, except that the website content is stored in a specially named gh-pages branch or in a docs folder on the master branch. The content will be rendered using Jekyll, and the output will become available under a subpath of your user pages subdomain, such as username.github.io/project (unless a custom domain is specified). The Jekyll project repository itself is a perfect example of this branch structureâ€”the master branch contains the actual software project for Jekyll, and the Jekyll website that youâ€™re looking at right now is contained in the docs folder of the same repository. Please refer to GitHub official documentation on user, organization and project pages to see more detailed examples.  Source files must be in the root directory  GitHub Pages overrides the â€œSite Sourceâ€ configuration value, so if you locate your files anywhere other than the root directory, your site may not build correctly.    Installing the github-pages gem on Windows  While Windows is not officially supported, it is possible to install the github-pages gem on Windows. Special instructions can be found on our Windows-specific docs page.  
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/github-pages/


includes/index
-----------------------------------------------------------
Includes The include tag allows you to include the content from another file stored in the _includes folder: {% include footer.html %}
 Jekyll will look for the referenced file (in this case, footer.html) in the _includes directory at the root of your source directory and insert its contents. Including files relative to another file You can choose to include file fragments relative to the current file by using the include_relative tag: {% include_relative somedir/footer.html %}
 You wonâ€™t need to place your included content within the _includes directory. Instead, the inclusion is specifically relative to the file where the tag is being used. For example, if _posts/2014-09-03-my-file.markdown uses the include_relative tag, the included file must be within the _posts directory or one of its subdirectories. Note that you cannot use the ../ syntax to specify an include location that refers to a higher-level directory. All the other capabilities of the include tag are available to the include_relative tag, such as variables. Using variables names for the include file The name of the file you want to embed can be specified as a variable instead of an actual file name. For example, suppose you defined a variable in your pageâ€™s front matter like this: ---
title: My page
my_variable: footer_company_a.html
---
 You could then reference that variable in your include: {% if page.my_variable %}
  {% include {{ page.my_variable }} %}
{% endif %}
 In this example, the include would insert the file footer_company_a.html from the _includes/footer_company_a.html directory. Passing parameters to includes You can also pass parameters to an include. For example, suppose you have a file called note.html in your _includes folder that contains this formatting: <div markdown="span" class="alert alert-info" role="alert">
<i class="fa fa-info-circle"></i> <b>Note:</b>
{{ include.content }}
</div>
 The {{ include.content }} is a parameter that gets populated when you call the include and specify a value for that parameter, like this: {% include note.html content="This is my sample note." %}
 The value of content (which is This is my sample note) will be inserted into the {{ include.content }} parameter. Passing parameters to includes is especially helpful when you want to hide away complex formatting from your Markdown content. For example, suppose you have a special image syntax with complex formatting, and you donâ€™t want your authors to remember the complex formatting. As a result, you decide to simplify the formatting by using an include with parameters. Hereâ€™s an example of the special image syntax you might want to populate with an include: <figure>
   <a href="http://jekyllrb.com">
   <img src="logo.png" style="max-width: 200px;"
      alt="Jekyll logo" />
   </a>
   <figcaption>This is the Jekyll logo</figcaption>
</figure>
 You could templatize this content in your include and make each value available as a parameter, like this: <figure>
   <a href="{{ include.url }}">
   <img src="{{ include.file }}" style="max-width: {{ include.max-width }};"
      alt="{{ include.alt }}"/>
   </a>
   <figcaption>{{ include.caption }}</figcaption>
</figure>
 This include contains 5 parameters:  url max-width file alt caption  Hereâ€™s an example that passes all the parameters to this include (the include file is named image.html): {% include image.html url="http://jekyllrb.com"
max-width="200px" file="logo.png" alt="Jekyll logo"
caption="This is the Jekyll logo." %}
 The result is the original HTML code shown earlier. To safeguard situations where users donâ€™t supply a value for the parameter, you can use Liquidâ€™s default filter. Overall, you can create includes that act as templates for a variety of uses â€” inserting audio or video clips, alerts, special formatting, and more. Note that you should avoid using too many includes, as this will slow down the build time of your site. For example, donâ€™t use includes every time you insert an image. (The above technique shows a use case for special images.) Passing parameter variables to includes Suppose the parameter you want to pass to the include is a variable rather than a string. For example, you might be using {{ site.product_name }} to refer to every instance of your product rather than the actual hard-coded name. (In this case, your _config.yml file would have a key called product_name with a value of your productâ€™s name.) The string you pass to your include parameter canâ€™t contain curly braces. For example, you canâ€™t pass a parameter that contains this: "The latest version of {{ site.product_name }} is now available." If you want to include this variable in your parameter that you pass to an include, you need to store the entire parameter as a variable before passing it to the include. You can use capture tags to create the variable: {% capture download_note %}
The latest version of {{ site.product_name }} is now available.
{% endcapture %}
 Then pass this captured variable into the parameter for the include. Omit the quotation marks around the parameter content because itâ€™s no longer a string (itâ€™s a variable): {% include note.html content=download_note %}

    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/includes/


installation/index
-----------------------------------------------------------
Installation Jekyll is a Ruby Gem that can be installed on most systems. Requirements  
Ruby version 2.4.0 or higher, including all development headers (check your Ruby version using ruby -v) 
RubyGems (check your Gems version using gem -v) 
GCC and Make (check versions using gcc -v,g++ -v, and make -v)  Guides For detailed install instructions, follow the guide for your operating system.  macOS Ubuntu Other Linux Windows 
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/installation/


installation/macos/index
-----------------------------------------------------------
Jekyll on macOS Install Command Line Tools To install the command line tools to compile native extensions, open a terminal and run: xcode-select --install
 Install Ruby Jekyll requires Ruby v2.4.0 or higher. macOS Catalina 10.15 ships with Ruby 2.6.3. Check your Ruby version using ruby -v. If youâ€™re running a previous version of macOS, youâ€™ll have to install a newer version of Ruby. With Homebrew To run the latest Ruby version you need to install it through Homebrew. # Install Homebrew
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
# Install Ruby
brew install ruby
 Add the brew ruby path to your shell configuration: # If you're using Zsh
echo 'export PATH="/usr/local/opt/ruby/bin:$PATH"' >> ~/.zshrc
# If you're using Bash
echo 'export PATH="/usr/local/opt/ruby/bin:$PATH"' >> ~/.bash_profile
# Unsure which shell you are using? Type
echo $SHELL
 Relaunch your terminal and check your Ruby setup: which ruby
# /usr/local/opt/ruby/bin/ruby
ruby -v
ruby 2.7.2p137 (2020-10-01 revision 5445e04352)
 Youâ€™re now running the current stable version of Ruby! With rbenv People often use rbenv to manage multiple Ruby versions. This is very useful when you need to be able to run a given Ruby version on a project. # Install Homebrew
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
# Install rbenv and ruby-build
brew install rbenv
# Set up rbenv integration with your shell
rbenv init
# Check your installation
curl -fsSL https://github.com/rbenv/rbenv-installer/raw/master/bin/rbenv-doctor | bash
 Restart your terminal to apply your changes. Next, you can install the Ruby version you want. Letâ€™s install the latest stable version: rbenv install 2.7.2
rbenv global 2.7.2
ruby -v
ruby 2.7.2p137 (2020-10-01 revision 5445e04352)
 Thatâ€™s it! Head over to rbenv command references to learn how to use different versions of Ruby in your projects. Install Jekyll After installing Ruby, install Jekyll and Bundler. Local Install Install the bundler and jekyll gems: gem install --user-install bundler jekyll
 Get your Ruby version: ruby -v
ruby 2.7.2p137 (2020-10-01 revision 5445e04352)
 Append your path file with the following, replacing the X.X with the first two digits of your Ruby version: # If you're using Zsh
echo 'export PATH="$HOME/.gem/ruby/X.X.0/bin:$PATH"' >> ~/.zshrc
# If you're using Bash
echo 'export PATH="$HOME/.gem/ruby/X.X.0/bin:$PATH"' >> ~/.bash_profile
# Unsure which shell you are using? Type
echo $SHELL
 Check that GEM PATHS: points to your home directory: gem env
 Every time you update Ruby to a version in which the first two digits change, update your path to match. Global Install We recommend not installing Ruby gems globally to avoid file permissions problems and using sudo. On Mojave (10.14) Because of SIP Protections in Mojave, run: sudo gem install bundler
sudo gem install -n /usr/local/bin/ jekyll
 Before Mojave (<10.14) Run: sudo gem install bundler jekyll
 Troubleshooting See Troubleshooting or ask for help on our forum.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/installation/macos/


installation/other-linux/index
-----------------------------------------------------------
Jekyll on Linux Installation on other Linux distributions works similarly to installing on Ubuntu. Install prerequisites Fedora sudo dnf install ruby ruby-devel openssl-devel redhat-rpm-config @development-tools
 RHEL8/CentOS8 sudo dnf install ruby ruby-devel
sudo dnf group install "Development Tools"
 Debian sudo apt-get install ruby-full build-essential
 Gentoo sudo emerge -av jekyll
 or sudo emerge --ask --verbose jekyll
 ArchLinux sudo pacman -S ruby base-devel
 OpenSUSE sudo zypper install -t pattern devel_ruby devel_C_C++
 Clear Linux sudo swupd bundle-add ruby-basic
 Install Jekyll Follow the instructions for Ubuntu.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/installation/other-linux/


installation/ubuntu/index
-----------------------------------------------------------
Jekyll on Ubuntu Install dependencies Install Ruby and other prerequisites: sudo apt-get install ruby-full build-essential zlib1g-dev
 Avoid installing RubyGems packages (called gems) as the root user. Instead, set up a gem installation directory for your user account. The following commands will add environment variables to your ~/.bashrc file to configure the gem installation path: echo '# Install Ruby Gems to ~/gems' >> ~/.bashrc
echo 'export GEM_HOME="$HOME/gems"' >> ~/.bashrc
echo 'export PATH="$HOME/gems/bin:$PATH"' >> ~/.bashrc
source ~/.bashrc
 Finally, install Jekyll and Bundler: gem install jekyll bundler
 Thatâ€™s it! Youâ€™re ready to start using Jekyll.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/installation/ubuntu/


installation/windows/index
-----------------------------------------------------------
Jekyll on Windows While Windows is not an officially-supported platform, it can be used to run Jekyll with the proper tweaks. Installing Ruby and Jekyll Installation via RubyInstaller The easiest way to install Ruby and Jekyll is by using the RubyInstaller for Windows. RubyInstaller is a self-contained Windows-based installer that includes the Ruby language, an execution environment, important documentation, and more. We only cover RubyInstaller-2.4 and newer here. Older versions need to install the Devkit manually.  Download and install a Ruby+Devkit version from RubyInstaller Downloads. Use default options for installation. Run the ridk install step on the last stage of the installation wizard. This is needed for installing gems with native extensions. You can find additional information regarding this in the RubyInstaller Documentation
 Open a new command prompt window from the start menu, so that changes to the PATH environment variable becomes effective. Install Jekyll and Bundler using gem install jekyll bundler
 Check if Jekyll has been installed properly: jekyll -v
  You may receive an error when checking if Jekyll has been installed properly. Reboot your system and run jekyll -v again. If the error persists, please open a RubyInstaller issue. Thatâ€™s it, youâ€™re ready to use Jekyll! Installation via Bash on Windows 10 If you are using Windows 10 version 1607 or later, another option to run Jekyll is by installing the Windows Subsystem for Linux. You must have Windows Subsystem for Linux enabled. Make sure all your packages and repositories are up to date. Open a new Command Prompt or Powershell window and type bash. Your terminal should now be a Bash instance. Next, update your repository lists and packages: sudo apt-get update -y && sudo apt-get upgrade -y
 Next, install Ruby. To do this, letâ€™s use a repository from BrightBox, which hosts optimized versions of Ruby for Ubuntu. sudo apt-add-repository ppa:brightbox/ruby-ng
sudo apt-get update
sudo apt-get install ruby2.5 ruby2.5-dev build-essential dh-autoreconf
 Next, update your Ruby gems: gem update
 Install Jekyll: gem install jekyll bundler
 No sudo here. Check your Jekyll version: jekyll -v
 Thatâ€™s it! Youâ€™re ready to start using Jekyll. You can make sure time management is working properly by inspecting your _posts folder. You should see a markdown file with the current date in the filename.  Non-superuser account issues If the `jekyll new` command prints the error "Your user account isn't allowed to install to the system RubyGems", see the "Running Jekyll as Non-Superuser" instructions in Troubleshooting.  Bash on Ubuntu on Windows is still under development, so you may run into issues. Encoding If you use UTF-8 encoding, make sure that no BOM header characters exist in your files. If they donâ€™t, Jekyll will break. This is especially relevant when youâ€™re running Jekyll on Windows. Additionally, you might need to change the code page of the console window to UTF-8 in case you get a Liquid Exception: Incompatible character encoding error during the site generation process. Run the following: chcp 65001
 Time Zone Management Since Windows doesnâ€™t have a native source of zoneinfo data, the Ruby Interpreter doesnâ€™t understand IANA Timezones. Using them had the TZ environment variable default to UTC/GMT 00:00. Though Windows users could alternatively define their blogâ€™s timezone by setting the key to use the POSIX format of defining timezones, it wasnâ€™t as user-friendly when it came to having the clock altered to changing DST-rules. Jekyll now uses a rubygem to internally configure Timezone based on established IANA Timezone Database. While â€˜newâ€™ blogs created with Jekyll v3.4 and greater, will have the following added to their Gemfile by default, existing sites will have to update their Gemfile (and installed gems) to enable development on Windows: # Windows does not include zoneinfo files, so bundle the tzinfo-data gem
gem 'tzinfo-data', platforms: [:mingw, :mswin, :x64_mingw, :jruby]
  TZInfo 2.0 incompatibility  Version 2.0 of the TZInfo library has introduced a change in how timezone offsets are calculated. This will result in incorrect date and time for your posts when the site is built with Jekyll 3.x on Windows.   We therefore recommend that you lock the Timezone library to version 1.2 and above by listing gem 'tzinfo', '~> 1.2' in your Gemfile.   Auto Regeneration Jekyll uses the listen gem to watch for changes when the --watch switch is specified during a build or serve. While listen has built-in support for UNIX systems, it may require an extra gem for compatibility with Windows. Add the following to the Gemfile for your site if you have issues with auto-regeneration on Windows alone: gem 'wdm', '~> 0.1.1', :install_if => Gem.win_platform?
 You have to use a Ruby+Devkit version of the RubyInstaller and install the MSYS2 build tools to successfully install the wdm gem.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/installation/windows/


layouts/index
-----------------------------------------------------------
Layouts Layouts are templates that wrap around your content. They allow you to have the source code for your template in one place so you donâ€™t have to repeat things like your navigation and footer on every page. Layouts live in the _layouts directory. The convention is to have a base template called default.html and have other layouts inherit from this as needed.  Layouts Directory  Jekyll looks for the _layouts directory either at the root of your site's source or at the root of your theme.   While you can configure the directory name in which your layouts can reside by setting the layouts_dir key in your config file, the directory itself should be located at the root of your site's source directory.   Usage The first step is to put the template source code in default.html. content is a special variable, the value is the rendered content of the post or page being wrapped. <!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>{{ page.title }}</title>
    <link rel="stylesheet" href="/css/style.css">
  </head>
  <body>
    <nav>
      <a href="/">Home</a>
      <a href="/blog/">Blog</a>
    </nav>
    <h1>{{ page.title }}</h1>
    <section>
      {{ content }}
    </section>
    <footer>
      &copy; to me
    </footer>
  </body>
</html>
 You have full access to the front matter of the origin. In the example above, page.title comes from the page front matter. Next you need to specify what layout youâ€™re using in your pageâ€™s front matter. You can also use front matter defaults to save you from having to set this on every page. ---
title: My First Page
layout: default
---
This is the content of my page
 The rendered output of this page is: <!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>My First Page</title>
    <link rel="stylesheet" href="/css/style.css">
  </head>
  <body>
    <nav>
      <a href="/">Home</a>
      <a href="/blog/">Blog</a>
    </nav>
    <h1>My First Page</h1>
    <section>
      This is the content of my page
    </section>
    <footer>
      &copy; to me
    </footer>
  </body>
</html>
 Inheritance Layout inheritance is useful when you want to add something to an existing layout for a portion of documents on your site. A common example of this is blog posts, you might want a post to display the date and author but otherwise be identical to your base layout. To achieve this you need to create another layout which specifies your original layout in front matter. For example this layout will live at _layouts/post.html: ---
layout: default
---
<p>{{ page.date }} - Written by {{ page.author }}</p>
{{ content }}
 Now posts can use this layout while the rest of the pages use the default. Variables You can set front matter in layouts, the only difference is when youâ€™re using in Liquid, you need to use the layout variable instead of page. For example: ---
city: San Francisco
---
<p>{{ layout.city }}</p>
{{ content }}

    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/layouts/


liquid/filters/index
-----------------------------------------------------------
Liquid Filters All of the standard Liquid filters are supported (see below). To make common tasks easier, Jekyll even adds a few handy filters of its own, all of which you can find on this page. You can also create your own filters using plugins.     Description 
Filter and Output
      Relative URL Prepend the baseurl value to the input. Useful if your site is hosted at a subpath rather than the root of the domain.   {{ "/assets/style.css" | relative_url }} /my-baseurl/assets/style.css     Absolute URL Prepend the url and baseurl value to the input.   {{ "/assets/style.css" | absolute_url }} http://example.com/my-baseurl/assets/style.css     Date to XML Schema Convert a Date into XML Schema (ISO 8601) format.   {{ site.time | date_to_xmlschema }} 2008-11-07T13:07:54-08:00     Date to RFC-822 Format Convert a Date into the RFC-822 format used for RSS feeds.   {{ site.time | date_to_rfc822 }} Mon, 07 Nov 2008 13:07:54 -0800     Date to String Convert a date to short format.   {{ site.time | date_to_string }} 07 Nov 2008     Date to String in ordinal US style Format a date to ordinal, US, short format. 3.8.0    {{ site.time | date_to_string: "ordinal", "US" }} Nov 7th, 2008     Date to Long String Format a date to long format.   {{ site.time | date_to_long_string }} 07 November 2008     Date to Long String in ordinal UK style Format a date to ordinal, UK, long format. 3.8.0    {{ site.time | date_to_long_string: "ordinal" }} 7th November 2008     Where Select all the objects in an array where the key has the given value.   {{ site.members | where:"graduation_year","2014" }}     Where Expression Select all the objects in an array where the expression is true. 3.2.0    {{ site.members | where_exp:"item",
"item.graduation_year == 2014" }} {{ site.members | where_exp:"item",
"item.graduation_year < 2014" }} {{ site.members | where_exp:"item",
"item.projects contains 'foo'" }}     Find Return the first object in an array for which the queried attribute has the given value or return nil if no item in the array satisfies the given criteria. 4.1.0    {{ site.members | find: "graduation_year", "2014" }}     Find Expression Return the first object in an array for which the given expression evaluates to true or return nil if no item in the array satisfies the evaluated expression. 4.1.0    {{ site.members | find_exp:"item",
"item.graduation_year == 2014" }} {{ site.members | find_exp:"item",
"item.graduation_year < 2014" }} {{ site.members | find_exp:"item",
"item.projects contains 'foo'" }}     Group By Group an array's items by a given property.   {{ site.members | group_by:"graduation_year" }} [{"name"=>"2013", "items"=>[...]},
{"name"=>"2014", "items"=>[...]}]     Group By Expression Group an array's items using a Liquid expression. 3.4.0    {{ site.members | group_by_exp: "item",
"item.graduation_year | truncate: 3, ''" }} [{"name"=>"201", "items"=>[...]},
{"name"=>"200", "items"=>[...]}]     XML Escape Escape some text for use in XML.   {{ page.content | xml_escape }}     CGI Escape CGI escape a string for use in a URL. Replaces any special characters with appropriate %XX replacements. CGI escape normally replaces a space with a plus + sign.   {{ "foo, bar; baz?" | cgi_escape }} foo%2C+bar%3B+baz%3F     URI Escape Percent encodes any special characters in a URI. URI escape normally replaces a space with %20. Reserved characters will not be escaped.   {{ "http://foo.com/?q=foo, \bar?" | uri_escape }} http://foo.com/?q=foo,%20%5Cbar?     Number of Words Count the number of words in some text. From v4.1.0, this filter takes an optional argument to control the handling of Chinese-Japanese-Korean (CJK) characters in the input string. Passing 'cjk' as the argument will count every CJK character detected as one word irrespective of being separated by whitespace. Passing 'auto' (auto-detect) works similar to 'cjk' but is more performant if the filter is used on a variable string that may or may not contain CJK chars.   {{ "Hello world!" | number_of_words }} 2 {{ "ä½ å¥½helloä¸–ç•Œworld" | number_of_words }} 1 {{ "ä½ å¥½helloä¸–ç•Œworld" | number_of_words: "cjk" }} 6 {{ "ä½ å¥½helloä¸–ç•Œworld" | number_of_words: "auto" }} 6     Array to Sentence Convert an array into a sentence. Useful for listing tags. Optional argument for connector.   {{ page.tags | array_to_sentence_string }} foo, bar, and baz {{ page.tags | array_to_sentence_string: "or" }} foo, bar, or baz     Markdownify Convert a Markdown-formatted string into HTML.   {{ page.excerpt | markdownify }}     Smartify Convert "quotes" into â€œsmart quotes.â€   {{ page.title | smartify }}     Converting Sass/SCSS Convert a Sass- or SCSS-formatted string into CSS.   {{ some_sass | sassify }} {{ some_scss | scssify }}     Slugify Convert a string into a lowercase URL "slug". See below for options.   {{ "The _config.yml file" | slugify }} the-config-yml-file {{ "The _config.yml file" | slugify: "pretty" }} the-_config.yml-file {{ "The _cÃ¶nfig.yml file" | slugify: "ascii" }} the-c-nfig-yml-file {{ "The cÃ¶nfig.yml file" | slugify: "latin" }} the-config-yml-file     Data To JSON Convert Hash or Array to JSON.   {{ site.data.projects | jsonify }}     Normalize Whitespace Replace any occurrence of whitespace with a single space.   {{ "a 
 b" | normalize_whitespace }}     Sort Sort an array. Optional arguments for hashes 1. property name 2. nils order (first or last).   {{ page.tags | sort }} {{ site.posts | sort: "author" }} {{ site.pages | sort: "title", "last" }}     Sample Pick a random value from an array. Optionally, pick multiple values.   {{ site.pages | sample }} {{ site.pages | sample: 2 }}     To Integer Convert a string or boolean to integer.   {{ some_var | to_integer }}     Array Filters Push, pop, shift, and unshift elements from an Array. These are NON-DESTRUCTIVE, i.e. they do not mutate the array, but rather make a copy and mutate that.   {{ page.tags | push: "Spokane" }} ["Seattle", "Tacoma", "Spokane"] {{ page.tags | pop }} ["Seattle"] {{ page.tags | shift }} ["Tacoma"] {{ page.tags | unshift: "Olympia" }} ["Olympia", "Seattle", "Tacoma"]     Inspect Convert an object into its String representation for debugging.   {{ some_var | inspect }}      Options for the slugify filter The slugify filter accepts an option, each specifying what to filter. The default is default. They are as follows (with what they filter):  
none: no characters 
raw: spaces 
default: spaces and non-alphanumeric characters 
pretty: spaces and non-alphanumeric characters except for ._~!$&'()+,;=@
 
ascii: spaces, non-alphanumeric, and non-ASCII characters 
latin: like default, except Latin characters are first transliterated (e.g. Ã Ã¨Ã¯Ã²Ã¼ to aeiou)3.7.0 .  Detecting nil values with where filter4.0
 You can use the where filter to detect documents and pages with properties that are nil or "". For example, // Using `nil` to select posts that either do not have `my_prop`
// defined or `my_prop` has been set to `nil` explicitly.
{% assign filtered_posts = site.posts | where: 'my_prop', nil %}
 // Using Liquid's special literal `empty` or `blank` to select
// posts that have `my_prop` set to an empty value.
{% assign filtered_posts = site.posts | where: 'my_prop', empty %}
 Binary operators in where_exp filter4.0
 You can use Liquid binary operators or and and in the expression passed to the where_exp filter to employ multiple conditionals in the operation. For example, to get a list of documents on English horror flicks, one could use the following snippet: {{ site.movies | where_exp: "item", "item.genre == 'horror' and item.language == 'English'" }}
 Or to get a list of comic-book based movies, one may use the following: {{ site.movies | where_exp: "item", "item.sub_genre == 'MCU' or item.sub_genre == 'DCEU'" }}
 Standard Liquid Filters For your convenience, here is the list of all Liquid filters with links to examples in the official Liquid documentation.   abs   append   at_least   at_most   capitalize   ceil   compact   concat   date   default   divided_by   downcase   escape   escape_once   first   floor   join   last   lstrip   map   minus   modulo   newline_to_br   plus   prepend   remove   remove_first   replace   replace_first   reverse   round   rstrip   size   slice   sort   sort_natural   split   strip   strip_html   strip_newlines   times   truncate   truncatewords   uniq   upcase   url_decode   url_encode  
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/liquid/filters/


liquid/index
-----------------------------------------------------------
Liquid Jekyll uses the Liquid templating language to process templates. Generally in Liquid you output content using two curly braces e.g. {{ variable }} and perform logic statements by surrounding them in a curly brace percentage sign e.g. {% if statement %}. To learn more about Liquid, check out the official Liquid Documentation. Jekyll provides a number of useful Liquid additions to help you build your site:  Filters Tags 
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/liquid/


liquid/tags/index
-----------------------------------------------------------
Tags Filters All of the standard Liquid tags are supported. Jekyll has a few built in tags to help you build your site. You can also create your own tags using plugins. Includes If you have page snippets that you use repeatedly across your site, an include is the perfect way to make this more maintainable. Code snippet highlighting Jekyll has built in support for syntax highlighting of over 100 languages thanks to Rouge. Rouge is the default highlighter in Jekyll 3 and above. Using Pygments has been deprecated and is not supported in Jekyll 4; the configuration setting highlighter: pygments now automatically falls back to using Rouge which is written in Ruby and 100% compatible with stylesheets for Pygments. To render a code block with syntax highlighting, surround your code as follows: {% highlight ruby %}
def foo
  puts 'foo'
end
{% endhighlight %}
 The argument to the highlight tag (ruby in the example above) is the language identifier. To find the appropriate identifier to use for the language you want to highlight, look for the â€œshort nameâ€ on the Rouge wiki.  Jekyll processes all Liquid filters in code blocks If you are using a language that contains curly braces, you will likely need to place {% raw %} and {% endraw %} tags around your code. Since Jekyll 4.0 , you can add render_with_liquid: false in your front matter to disable Liquid entirely for a particular document.  Line numbers There is a second argument to highlight called linenos that is optional. Including the linenos argument will force the highlighted code to include line numbers. For instance, the following code block would include line numbers next to each line: {% highlight ruby linenos %}
def foo
  puts 'foo'
end
{% endhighlight %}
 Stylesheets for syntax highlighting In order for the highlighting to show up, youâ€™ll need to include a highlighting stylesheet. For Pygments or Rouge you can use a stylesheet for Pygments, you can find an example gallery here or from its repository. Copy the CSS file (native.css for example) into your css directory and import the syntax highlighter styles into your main.css: @import "native.css";
 Links Since Jekyll 4.0 , you donâ€™t need to prepend link and post_url tags with site.baseurl. Linking to pages To link to a post, a page, collection item, or file, the link tag will generate the correct permalink URL for the path you specify. For example, if you use the link tag to link to mypage.html, even if you change your permalink style to include the file extension or omit it, the URL formed by the link tag will always be valid. You must include the fileâ€™s original extension when using the link tag. Here are some examples: {% link _collection/name-of-document.md %}
{% link _posts/2016-07-26-name-of-post.md %}
{% link news/index.html %}
{% link /assets/files/doc.pdf %}
 You can also use the link tag to create a link in Markdown as follows: [Link to a document]({% link _collection/name-of-document.md %})
[Link to a post]({% link _posts/2016-07-26-name-of-post.md %})
[Link to a page]({% link news/index.html %})
[Link to a file]({% link /assets/files/doc.pdf %})
 The path to the post, page, or collection is defined as the path relative to the root directory (where your config file is) to the file, not the path from your existing page to the other page. For example, suppose youâ€™re creating a link in page_a.md (stored in pages/folder1/folder2) to page_b.md (stored in pages/folder1). Your path in the link would not be ../page_b.html. Instead, it would be /pages/folder1/page_b.md. If youâ€™re unsure of the path, add {{ page.path }} to the page and it will display the path. One major benefit of using the link or post_url tag is link validation. If the link doesnâ€™t exist, Jekyll wonâ€™t build your site. This is a good thing, as it will alert you to a broken link so you can fix it (rather than allowing you to build and deploy a site with broken links). Note you cannot add filters to link tags. For example, you cannot append a string using Liquid filters, such as {% link mypage.html | append: "#section1" %}. To link to sections on a page, you will need to use regular HTML or Markdown linking techniques. The name of the file you want to link can be specified as a variable instead of an actual file name. For example, suppose you defined a variable in your pageâ€™s front matter like this: ---
title: My page
my_variable: footer_company_a.html
---
 You could then reference that variable in your link: {% link {{ page.my_variable }} %}
 In this example, the link tag would render a link to the file footer_company_a.html. Linking to posts If you want to include a link to a post on your site, the post_url tag will generate the correct permalink URL for the post you specify. {% post_url 2010-07-21-name-of-post %}
 If you organize your posts in subdirectories, you need to include subdirectory path to the post: {% post_url /subdir/2010-07-21-name-of-post %}
 There is no need to include the file extension when using the post_url tag. You can also use this tag to create a link to a post in Markdown as follows: [Name of Link]({% post_url 2010-07-21-name-of-post %})

    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/liquid/tags/


migrations/index
-----------------------------------------------------------
Blog Migrations If youâ€™re switching to Jekyll from another blogging system, Jekyllâ€™s importers can help you with the move. To learn more about importing your site to Jekyll, visit our jekyll-import docs site.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/migrations/


pages/index
-----------------------------------------------------------
Pages Pages are the most basic building block for content. Theyâ€™re useful for standalone content (content which is not date based or is not a group of content such as staff members or recipes). The simplest way of adding a page is to add an HTML file in the root directory with a suitable filename. You can also write a page in Markdown using a .md extension which converts to HTML on build. For a site with a homepage, an about page, and a contact page, hereâ€™s what the root directory and associated URLs might look like: .
â”œâ”€â”€ about.md    # => http://example.com/about.html
â”œâ”€â”€ index.html    # => http://example.com/
â””â”€â”€ contact.html  # => http://example.com/contact.html
 If you have a lot of pages, you can organize them into subfolders. The same subfolders that are used to group your pages in your projectâ€™s source will then exist in the _site folder when your site builds. However, when a page has a different permalink set in the front matter, the subfolder at _site changes accordingly. .
â”œâ”€â”€ about.md          # => http://example.com/about.html
â”œâ”€â”€ documentation     # folder containing pages
â”‚   â””â”€â”€ doc1.md       # => http://example.com/documentation/doc1.html
â”œâ”€â”€ design            # folder containing pages
â”‚   â””â”€â”€ draft.md      # => http://example.com/design/draft.html
 Changing the output URL You might want to have a particular folder structure for your source files that changes for the built site. With permalinks you have full control of the output URL. Excerpts for pages From Jekyll 4.1.1 onwards, one can choose to generate excerpts for their pages by setting page_excerpts to true in their config file.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/pages/


pagination/index
-----------------------------------------------------------
Pagination With many websites â€” especially blogs â€” itâ€™s very common to break the main listing of posts up into smaller lists and display them over multiple pages. Jekyll offers a pagination plugin, so you can automatically generate the appropriate files and folders you need for paginated listings. For Jekyll 3, include the jekyll-paginate plugin in your Gemfile and in your _config.yml under plugins. For Jekyll 2, this is standard.  Pagination only works within HTML files  Pagination does not work from within Markdown files from your Jekyll site. Pagination works when called from within the HTML file, named index.html, which optionally may reside in and produce pagination from within a subdirectory, via the paginate_path configuration value.   Enable pagination To enable pagination for posts on your blog, add a line to the _config.yml file that specifies how many items should be displayed per page: paginate: 5
 The number should be the maximum number of Posts youâ€™d like to be displayed per-page in the generated site. You may also specify the destination of the pagination pages: paginate_path: "/blog/page:num/"
 This will read in blog/index.html, send it each pagination page in Liquid as paginator and write the output to blog/page:num/, where :num is the pagination page number, starting with 2.  If a site has 12 posts and specifies paginate: 5, Jekyll will write blog/index.html with the first 5 posts, blog/page2/index.html with the next 5 posts and blog/page3/index.html with the last 2 posts into the destination directory.  Don't set a permalink  Setting a permalink in the front matter of your blog page will cause pagination to break. Just omit the permalink.    Pagination for categories, tags and collections  The more recent  jekyll-paginate-v2 plugin supports more features. See the  pagination examples in the repository. This plugin is not supported by GitHub Pages.   Liquid Attributes Available The pagination plugin exposes the paginator liquid object with the following attributes:     Variable Description     paginator.page The number of the current page   paginator.per_page Number of posts per page   paginator.posts Posts available for the current page   paginator.total_posts Total number of posts   paginator.total_pages Total number of pages   paginator.previous_page The number of the previous page, or nil if no previous page exists   paginator.previous_page_path The path to the previous page, or nil if no previous page exists   paginator.next_page The number of the next page, or nil if no subsequent page exists   paginator.next_page_path The path to the next page, or nil if no subsequent page exists      Pagination does not support tags or categories Pagination pages through every post in the posts variable unless a post has hidden: true in its front matter. It does not currently allow paging over groups of posts linked by a common tag or category. It cannot include any collection of documents because it is restricted to posts.  Render the paginated Posts The next thing you need to do is to actually display your posts in a list using the paginator variable that will now be available to you. Youâ€™ll probably want to do this in one of the main pages of your site. Hereâ€™s one example of a simple way of rendering paginated Posts in a HTML file: ---
layout: default
title: My Blog
---
<!-- This loops through the paginated posts -->
{% for post in paginator.posts %}
  <h1><a href="{{ post.url }}">{{ post.title }}</a></h1>
  <p class="author">
    <span class="date">{{ post.date }}</span>
  </p>
  <div class="content">
    {{ post.content }}
  </div>
{% endfor %}
<!-- Pagination links -->
<div class="pagination">
  {% if paginator.previous_page %}
    <a href="{{ paginator.previous_page_path }}" class="previous">
      Previous
    </a>
  {% else %}
    <span class="previous">Previous</span>
  {% endif %}
  <span class="page_number ">
    Page: {{ paginator.page }} of {{ paginator.total_pages }}
  </span>
  {% if paginator.next_page %}
    <a href="{{ paginator.next_page_path }}" class="next">Next</a>
  {% else %}
    <span class="next ">Next</span>
  {% endif %}
</div>
  Beware the page one edge-case  Jekyll does not generate a â€˜page1â€™ folder, so the above code will not work when a /page1 link is produced. See below for a way to handle this if itâ€™s a problem for you.   The following HTML snippet should handle page one, and render a list of each page with links to all but the current page. {% if paginator.total_pages > 1 %}
<div class="pagination">
  {% if paginator.previous_page %}
    <a href="{{ paginator.previous_page_path | relative_url }}">&laquo; Prev</a>
  {% else %}
    <span>&laquo; Prev</span>
  {% endif %}
  {% for page in (1..paginator.total_pages) %}
    {% if page == paginator.page %}
      <em>{{ page }}</em>
    {% elsif page == 1 %}
      <a href="{{ '/' | relative_url }}">{{ page }}</a>
    {% else %}
      <a href="{{ site.paginate_path | relative_url | replace: ':num', page }}">{{ page }}</a>
    {% endif %}
  {% endfor %}
  {% if paginator.next_page %}
    <a href="{{ paginator.next_page_path | relative_url }}">Next &raquo;</a>
  {% else %}
    <span>Next &raquo;</span>
  {% endif %}
</div>
{% endif %}

    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/pagination/


permalinks/index
-----------------------------------------------------------
Permalinks Permalinks are the output path for your pages, posts, or collections. They allow you to structure the directories of your source code different from the directories in your output. Front Matter The simplest way to set a permalink is using front matter. You set the permalink variable in front matter to the output path youâ€™d like. For example, you might have a page on your site located at /my_pages/about-me.html and you want the output url to be /about/. In front matter of the page you would set: ---
permalink: /about/
---
 Global Setting a permalink in front matter for every page on your site is no fun. Luckily, Jekyll lets you set the permalink structure globally in your _config.yml. To set a global permalink, you use the permalink variable in _config.yml. You can use placeholders to your desired output. For example: permalink: /:categories/:year/:month/:day/:title:output_ext
 Note that pages and collections (excluding posts and drafts) donâ€™t have time and categories (for pages, the above :title is equivalent to :basename), these aspects of the permalink style are ignored for the output. For example, a permalink style of /:categories/:year/:month/:day/:title:output_ext for the posts collection becomes /:title.html for pages and collections (excluding posts and drafts). Placeholders Hereâ€™s the full list of placeholders available:     Variable Description      year    Year from the postâ€™s filename with four digits. May be overridden via the documentâ€™s date front matter.      short_year    Year from the postâ€™s filename without the century. (00..99) May be overridden via the documentâ€™s date front matter.      month    Month from the postâ€™s filename. (01..12) May be overridden via the documentâ€™s date front matter.      i_month    Month without leading zeros from the postâ€™s filename. May be overridden via the documentâ€™s date front matter.      short_month   Three-letter month abbreviation, e.g. â€œJanâ€.     long_month 4.0    Full month name, e.g. â€œJanuaryâ€.     day    Day of the month from the postâ€™s filename. (01..31) May be overridden via the documentâ€™s date front matter.      i_day    Day of the month without leading zeros from the postâ€™s filename. May be overridden via the documentâ€™s date front matter.      y_day   Ordinal day of the year from the postâ€™s filename, with leading zeros. (001..366)     w_year 4.0    Week year which may differ from the month year for up to three days at the start of January and end of December     week 4.0    Week number of the current year, starting with the first week having a majority of its days in January. (01..53)     w_day 4.0    Day of the week, starting with Monday. (1..7)     short_day 4.0    Three-letter weekday abbreviation, e.g. â€œSunâ€.     long_day 4.0    Weekday name, e.g. â€œSundayâ€.     hour    Hour of the day, 24-hour clock, zero-padded from the postâ€™s date front matter. (00..23)      minute    Minute of the hour from the postâ€™s date front matter. (00..59)      second    Second of the minute from the postâ€™s date front matter. (00..59)      title    Title from the documentâ€™s filename. May be overridden via the documentâ€™s slug front matter.      slug    Slugified title from the documentâ€™s filename (any character except numbers and letters is replaced as hyphen). May be overridden via the documentâ€™s slug front matter.      categories    The specified categories for this post. If a post has multiple categories, Jekyll will create a hierarchy (e.g. /category1/category2). Also Jekyll automatically parses out double slashes in the URLs, so if no categories are present, it will ignore this.      slugified_categories 4.1     The specified categories for this post but slugified. If a category is a composite of multiple words, Jekyll will downcase all alphabets and replace any non-alphanumeric character with a hyphen. (e.g. "Work 2 Progress" will be converted into "work-2-progress")   If a post has multiple categories, Jekyll will create a hierarchy (e.g. /work-2-progress/category2). Also Jekyll automatically parses out double slashes in the URLs, so if no categories are present, it will ignore this.       Built-in formats For posts, Jekyll also provides the following built-in styles for convenience:     Permalink Style URL Template      date   /:categories/:year/:month/:day/:title:output_ext     pretty   /:categories/:year/:month/:day/:title/     ordinal   /:categories/:year/:y_day/:title:output_ext     weekdate 4.0    /:categories/:year/W:week/:short_day/:title:output_ext     none   /:categories/:title:output_ext      Rather than typing permalink: /:categories/:year/:month/:day/:title/, you can just type permalink: pretty.  Specifying permalinks through the front matter Built-in permalink styles are not recognized in front matter. As a result, permalink: pretty will not work.  Collections For collections (including posts and drafts), you have the option to override the global permalink in the collection configuration in _config.yml: collections:
  my_collection:
    output: true
    permalink: /:collection/:name
 Collections have the following placeholders available:     Variable Description      :collection   Label of the containing collection.     :path    Path to the document relative to the collection's directory, including base filename of the document.      :name   The document's base filename, with every sequence of spaces and non-alphanumeric characters replaced by a hyphen.     :title    The :title template variable will take the slug front matter variable value if any is present in the document; if none is defined then :title will be equivalent to :name, aka the slug generated from the filename.      :output_ext   Extension of the output file. (Included by default and usually unnecessary.)      Pages For pages, you have to use front matter to override the global permalink, and if you set a permalink via front matter defaults in _config.yml, it will be ignored. Pages have the following placeholders available:     Variable Description      :path    Path to the page relative to the site's source directory, excluding base filename of the page.      :basename   The page's base filename     :output_ext    Extension of the output file. (Included by default and usually unnecessary.)      
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/permalinks/


plugins/commands/index
-----------------------------------------------------------
Commands As of version 2.5.0 , Jekyll can be extended with plugins which provide subcommands for the jekyll executable. This is possible by including the relevant plugins in a Gemfile group called :jekyll_plugins: group :jekyll_plugins do
  gem "my_fancy_jekyll_plugin"
end
 Each Command must be a subclass of the Jekyll::Command class and must contain one class method: init_with_program. An example: class MyNewCommand < Jekyll::Command
  class << self
    def init_with_program(prog)
      prog.command(:new) do |c|
        c.syntax "new [options]"
        c.description 'Create a new Jekyll site.'
        c.option 'dest', '-d DEST', 'Where the site should go.'
        c.action do |args, options|
          Jekyll::Site.new_site_at(options['dest'])
        end
      end
    end
  end
end
 Commands should implement this single class method:     Method Description      init_with_program   This method accepts one parameter, the Mercenary::Program instance, which is the Jekyll program itself. Upon the program, commands may be created using the above syntax. For more details, visit the Mercenary repository on GitHub.com.     
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/plugins/commands/


plugins/converters/index
-----------------------------------------------------------
Converters If you have a new markup language youâ€™d like to use with your site, you can include it by implementing your own converter. Both the Markdown and Textile markup languages are implemented using this method.  Remember your Front Matter  Jekyll will only convert files that have a YAML header at the top, even for converters you add using a plugin.   Below is a converter that will take all posts ending in .upcase and process them using the UpcaseConverter: module Jekyll
  class UpcaseConverter < Converter
    safe true
    priority :low
    def matches(ext)
      ext =~ /^\.upcase$/i
    end
    def output_ext(ext)
      ".html"
    end
    def convert(content)
      content.upcase
    end
  end
end
 Converters should implement at a minimum 3 methods:     Method Description      matches   Does the given extension match this converterâ€™s list of acceptable extensions? Takes one argument: the fileâ€™s extension (including the dot). Must return true if it matches, false otherwise.     output_ext   The extension to be given to the output file (including the dot). Usually this will be ".html".     convert   Logic to do the content conversion. Takes one argument: the raw content of the file (without front matter). Must return a String.      In our example, UpcaseConverter#matches checks if our filename extension is .upcase, and will render using the converter if it is. It will call UpcaseConverter#convert to process the content. In our simple converter weâ€™re simply uppercasing the entire content string. Finally, when it saves the page, it will do so with a .html extension.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/plugins/converters/


plugins/filters/index
-----------------------------------------------------------
Filters Filters are modules that export their methods to liquid. All methods will have to take at least one parameter which represents the input of the filter. The return value will be the output of the filter. module Jekyll
  module AssetFilter
    def asset_url(input)
      "http://www.example.com/#{input}?#{Time.now.to_i}"
    end
  end
end
Liquid::Template.register_filter(Jekyll::AssetFilter)
  ProTipâ„¢: Access the site object using Liquid  Jekyll lets you access the site object through the @context.registers feature of Liquid at @context.registers[:site]. For example, you can access the global configuration file _config.yml using @context.registers[:site].config.  
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/plugins/filters/


plugins/generators/index
-----------------------------------------------------------
Generators You can create a generator when you need Jekyll to create additional content based on your own rules. A generator is a subclass of Jekyll::Generator that defines a generate method, which receives an instance of Jekyll::Site. The return value of generate is ignored. Generators run after Jekyll has made an inventory of the existing content, and before the site is generated. Pages with front matter are stored as instances of Jekyll::Page and are available via site.pages. Static files become instances of Jekyll::StaticFile and are available via site.static_files. See the Variables documentation page and Jekyll::Site for details. For instance, a generator can inject values computed at build time for template variables. In the following example, the template reading.html has two variables ongoing and done that are filled in the generator: module Reading
  class Generator < Jekyll::Generator
    def generate(site)
      ongoing, done = Book.all.partition(&:ongoing?)
      reading = site.pages.detect {|page| page.name == 'reading.html'}
      reading.data['ongoing'] = ongoing
      reading.data['done'] = done
    end
  end
end
 The following example is a more complex generator that generates new pages. In this example, the generator will create a series of files under the categories directory for each category, listing the posts in each category using the category_index.html layout. module Jekyll
  class CategoryPageGenerator < Generator
    safe true
    def generate(site)
      if site.layouts.key? 'category_index'
        dir = site.config['category_dir'] || 'categories'
        site.categories.each_key do |category|
          site.pages << CategoryPage.new(site, site.source, File.join(dir, category), category)
        end
      end
    end
  end
  # A Page subclass used in the `CategoryPageGenerator`
  class CategoryPage < Page
    def initialize(site, base, dir, category)
      @site = site
      @base = base
      @dir  = dir
      @name = 'index.html'
      self.process(@name)
      self.read_yaml(File.join(base, '_layouts'), 'category_index.html')
      self.data['category'] = category
      category_title_prefix = site.config['category_title_prefix'] || 'Category: '
      self.data['title'] = "#{category_title_prefix}#{category}"
    end
  end
end
 Generators need to implement only one method:     Method Description      generate   Generates content as a side-effect.      If your generator is contained within a single file, it can be named whatever you want but it should have an .rb extension. If your generator is split across multiple files, it should be packaged as a Rubygem to be published at https://rubygems.org/. In this case, the name of the gem depends on the availability of the name at that site because no two gems can have the same name. By default, Jekyll looks for generators in the _plugins directory. However, you can change the default directory by assigning the desired name to the key plugins_dir in the config file.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/plugins/generators/


plugins/hooks/index
-----------------------------------------------------------
Hooks Using hooks, your plugin can exercise fine-grained control over various aspects of the build process. If your plugin defines any hooks, Jekyll will call them at pre-defined points. Hooks are registered to an owner and an event name. To register one, you call Jekyll::Hooks.register, and pass the hook owner, event name, and code to call whenever the hook is triggered. For example, if you want to execute some custom functionality every time Jekyll renders a page, you could register a hook like this: Jekyll::Hooks.register :pages, :post_render do |page|
  # code to call after Jekyll renders a page
end
 Note: The :post_convert events mentioned hereafter is a feature introduced in v4.2.0. Out of the box, Jekyll has pre-defined hook points for owners :site, :pages, :documents and :clean. Additionally, the hook points defined for :documents can be utilized for individual collections only by invoking the collection type instead. i.e. :posts for documents in collection _posts and :movies for documents in collection _movies. In all cases, Jekyll calls your hooks with the owner object as the first callback parameter. Every registered hook owner supports the following events â€” :post_init, :pre_render, :post_convert, :post_render, :post_write â€” however, the :site owner is set up to respond to special event names. Refer to the subsequent section for details. All :pre_render hooks and the :site, :post_render hook will also provide a payload hash as a second parameter. While in the case of :pre_render events, the payload gives you full control over the variables that are available during rendering, with the :site, :post_render event, the payload contains final values after rendering all the site (useful for sitemaps, feeds, etc). Built-in Hook Owners and Events The complete list of available hooks:     Owner Event Triggered at      :site Encompasses the entire site   :after_init   Just after the site initializes. Good for modifying the configuration of the site. Triggered once per build / serve session     :after_reset   Just after the site resets during regeneration     :post_read   After all source files have been read and loaded from disk     :pre_render   Just before rendering the whole site     :post_render   After rendering the whole site, but before writing any files     :post_write   After writing all of the rendered files to disk     :pages Allows fine-grained control over all pages in the site   :post_init   Whenever a page is initialized     :pre_render   Just before rendering a page     :post_convert   After converting the page content, but before rendering the page layout     :post_render   After rendering a page, but before writing it to disk     :post_write   After writing a page to disk     :documents Allows fine-grained control over all documents in the site including posts and documents in user-defined collections   :post_init   Whenever any document is initialized     :pre_render   Just before rendering a document     :post_convert    After converting the document content, but before rendering the document layout      :post_render   After rendering a document, but before writing it to disk     :post_write   After writing a document to disk     :posts Allows fine-grained control over all posts in the site without affecting documents in user-defined collections   :post_init   Whenever a post is initialized     :pre_render   Just before rendering a post     :post_convert   After converting the post content, but before rendering the postlayout     :post_render   After rendering a post, but before writing it to disk     :post_write   After writing a post to disk     :clean Fine-grained control on the list of obsolete files determined to be deleted during the site's cleanup phase.   :on_obsolete   During the cleanup of a site's destination before it is built      Hooks for custom Jekyll objects You can also register and trigger hooks for Jekyll objects introduced by your plugin. All it takes is placing trigger calls under a suitable owner name, at positons desired within your custom class and registering the owner by your plugin. To illustrate, consider the following plugin that implements custom functionality for every custom Excerpt object initialized: module Foobar
  class HookedExcerpt < Jekyll::Excerpt
    def initialize(doc)
      super
      trigger_hooks(:post_init)
    end
    def output
      @output ||= trigger_hooks(:post_render, renderer.run)
    end
    def renderer
      @renderer ||= Jekyll::Renderer.new(
        doc.site, self, site.site_payload
      )
    end
    def trigger_hooks(hook_name, *args)
      Jekyll::Hooks.trigger :excerpts, hook_name, self, *args
    end
  end
end
Jekyll::Hooks.register :excerpts, :post_init do |excerpt|
  Jekyll.logger.debug "Initialized:",
                      "Hooked Excerpt for #{excerpt.doc.inspect}"
end
Jekyll::Hooks.register :excerpts, :post_render do |excerpt, output|
  return output unless excerpt.doc.type == :posts
  Foobar.transform(output)
end

    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/plugins/hooks/


plugins/index
-----------------------------------------------------------
Plugins Jekyll has a plugin system with hooks that allow you to create custom generated content specific to your site. You can run custom code for your site without having to modify the Jekyll source itself. You can add specific plugins to the whitelist key in _config.yml to allow them to run in safe mode.  
Installation - How to install plugins 
Your first plugin - How to write plugins 
Generators - Create additional content on your site 
Converters - Change a markup language into another format 
Commands - Extend the jekyll executable with subcommands 
Tags - Create custom Liquid tags 
Filters - Create custom Liquid filters 
Hooks - Fine-grained control to extend the build process 
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/plugins/


plugins/installation/index
-----------------------------------------------------------
Plugins You have 3 options for installing plugins:   In your site source root, make a _plugins directory. Place your plugins here. Any file ending in *.rb inside this directory will be loaded before Jekyll generates your site.   In your _config.yml file, add a new array with the key plugins (or gems for Jekyll < 3.5.0) and the values of the gem names of the plugins youâ€™d like to use. An example: # This will require each of these plugins automatically.
plugins:
  - jekyll-gist
  - jekyll-coffeescript
  - jekyll-assets
  - another-jekyll-plugin
 Then install your plugins using gem install jekyll-gist jekyll-coffeescript jekyll-assets another-jekyll-plugin   Add the relevant plugins to a Bundler group in your Gemfile. An example: group :jekyll_plugins do
  gem "jekyll-gist"
  gem "jekyll-coffeescript"
  gem "jekyll-assets"
  gem "another-jekyll-plugin"
end
 Now you need to install all plugins from your Bundler group by running single command bundle install.    Plugins on GitHub Pages  GitHub Pages is powered by Jekyll. All Pages sites are generated using the --safe option to disable plugins (with the exception of some whitelisted plugins) for security reasons. Unfortunately, this means your plugins wonâ€™t work if youâ€™re deploying to GitHub Pages. You can still use GitHub Pages to publish your site, but youâ€™ll need to convert the site locally and push the generated static files to your GitHub repository instead of the Jekyll source files.     _plugins, _config.yml and Gemfile can be used simultaneously   You may use any of the aforementioned plugin options simultaneously in the same site if you so choose. Use of one does not restrict the use of the others.   The jekyll_plugins group Jekyll gives this particular group of gems in your Gemfile a different treatment. Any gem included in this group is loaded before Jekyll starts processing the rest of your source directory. A gem included here will be activated even if its not explicitly listed under the plugins: key in your siteâ€™s config file. Gems included in the :jekyll-plugins group are activated regardless of the --safe mode setting. Be aware of which gems are included under this group!
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/plugins/installation/


plugins/tags/index
-----------------------------------------------------------
Tags If youâ€™d like to include custom liquid tags in your site, you can do so by hooking into the tagging system. Built-in examples added by Jekyll include the highlight and include tags. Below is an example of a custom liquid tag that will output the time the page was rendered: module Jekyll
  class RenderTimeTag < Liquid::Tag
    def initialize(tag_name, text, tokens)
      super
      @text = text
    end
    def render(context)
      "#{@text} #{Time.now}"
    end
  end
end
Liquid::Template.register_tag('render_time', Jekyll::RenderTimeTag)
 At a minimum, liquid tags must implement:     Method Description      render   Outputs the content of the tag.      You must also register the custom tag with the Liquid template engine as follows: Liquid::Template.register_tag('render_time', Jekyll::RenderTimeTag)
 In the example above, we can place the following tag anywhere in one of our pages: <p>{% render_time page rendered at: %}</p>
 And we would get something like this on the page: <p>page rendered at: Tue June 22 23:38:47 â€“0500 2010</p>
 Tag Blocks The render_time tag seen above can also be rewritten as a tag block by inheriting the Liquid::Block class. Look at the example below: module Jekyll
  class RenderTimeTagBlock < Liquid::Block
    def render(context)
      text = super
      "<p>#{text} #{Time.now}</p>"
    end
  end
end
Liquid::Template.register_tag('render_time', Jekyll::RenderTimeTagBlock)
 We can now use the tag block anywhere: {% render_time %}
page rendered at:
{% endrender_time %}
 And we would still get the same output as above on the page: <p>page rendered at: Tue June 22 23:38:47 â€“0500 2010</p>
 In the above example, the tag block and the tag are both registered with the name render_time, but to register a tag and a tag block using the same name in the same project is not recommended as this may lead to conflicts.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/plugins/tags/


plugins/your-first-plugin/index
-----------------------------------------------------------
Your first plugin Plugins allow you to extend Jekyllâ€™s behavior to fit your needs. There are six types of plugins in Jekyll. Generators Generators create content on your site. For example:   jekyll-feed creates an Atom feed of blog posts.  jekyll-archives creates archive pages for blog categories and tags.  jekyll-sitemap creates a sitemap.  Converters Converters change a markup language into another format. For example:   jekyll-textile-converter converts textile to HTML.  jekyll-coffeescript converts Coffeescript to JavaScript.  jekyll-opal converts Ruby to JavaScript.  Commands Commands extend the jekyll executable with subcommands. For example:   jekyll-compose adds subcommands for creating a post, page or draft.  Tags Tags create custom Liquid tags. For example:   jekyll-youtube embeds a YouTube video.  jekyll-asset-path-plugin outputs a relative URL for assets.  jekyll-swfobject embeds a SWF object.  Filters Filters create custom Liquid filters. For example:   jekyll-time-ago - The distance between two dates in words.  jekyll-toc - Generates a table of content.  jekyll-email-protect - Obfuscates emails to protect them from spam bots.  Hooks Hooks give fine-grained control to extend the build process. For example:   jemoji Display emojis    jekyll-mentions turns mentions @jekyll into links  jekyll-spaceship - advanced example. Provides powerful supports for table, mathjax, plantuml, video, etc.  Flags There are two flags to be aware of when writing a plugin:     Flag Description      safe    A boolean flag that informs Jekyll whether this plugin may be safely executed in an environment where arbitrary code execution is not allowed. This is used by GitHub Pages to determine which core plugins may be used, and which are unsafe to run. If your plugin does not allow for arbitrary code execution, set this to true. GitHub Pages still wonâ€™t load your plugin, but if you submit it for inclusion in core, itâ€™s best for this to be correct!      priority    This flag determines what order the plugin is loaded in. Valid values are: :lowest, :low, :normal, :high, and :highest. Highest priority matches are applied first, lowest priority are applied last.       To use one of the example plugins above as an illustration, here is how youâ€™d specify these two flags: module Jekyll
  class UpcaseConverter < Converter
    safe true
    priority :low
    ...
  end
end
 Best Practices The guides help you with the specifics of creating plugins. We also have some recommended best practices to help structure your plugin. We recommend using a gem for your plugin. This will help you manage dependencies, keep separation from your site source code and allow you to share functionality across multiple projects. For tips on creating a gem take a look at the Ruby gems guide or look through the source code of an existing plugin such as jekyll-feed.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/plugins/your-first-plugin/


posts/index
-----------------------------------------------------------
Posts Blogging is baked into Jekyll. You write blog posts as text files and Jekyll provides everything you need to turn it into a blog. The Posts Folder The _posts folder is where your blog posts live. You typically write posts in Markdown, HTML is also supported. Creating Posts To create a post, add a file to your _posts directory with the following format: YEAR-MONTH-DAY-title.MARKUP
 Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and MARKUP is the file extension representing the format used in the file. For example, the following are examples of valid post filenames: 2011-12-31-new-years-eve-is-awesome.md
2012-09-12-how-to-write-a-blog.md
 All blog post files must begin with front matter which is typically used to set a layout or other meta data. For a simple example this can just be empty: ---
layout: post
title:  "Welcome to Jekyll!"
---
# Welcome
**Hello world**, this is my first Jekyll blog post.
I hope you like it!
  ProTipâ„¢: Link to other posts  Use the post_url tag to link to other posts without having to worry about the URLs breaking when the site permalink style changes.    Be aware of character sets  Content processors can modify certain characters to make them look nicer. For example, the smart extension in Redcarpet converts standard, ASCII quotation characters to curly, Unicode ones. In order for the browser to display those characters properly, define the charset meta value by including <meta charset="utf-8"> in the <head> of your layout.   Including images and resources At some point, youâ€™ll want to include images, downloads, or other digital assets along with your text content. One common solution is to create a folder in the root of the project directory called something like assets, into which any images, files or other resources are placed. Then, from within any post, they can be linked to using the siteâ€™s root as the path for the asset to include. The best way to do this depends on the way your siteâ€™s (sub)domain and path are configured, but here are some simple examples in Markdown: Including an image asset in a post: ... which is shown in the screenshot below:
![My helpful screenshot](/assets/screenshot.jpg)
 Linking to a PDF for readers to download: ... you can [get the PDF](/assets/mydoc.pdf) directly.
 Displaying an index of posts Creating an index of posts on another page should be easy thanks to Liquid and its tags. Hereâ€™s a simple example of how to create a list of links to your blog posts: <ul>
  {% for post in site.posts %}
    <li>
      <a href="{{ post.url }}">{{ post.title }}</a>
    </li>
  {% endfor %}
</ul>
 You have full control over how (and where) you display your posts, and how you structure your site. You should read more about how templates work with Jekyll if you want to know more. Note that the post variable only exists inside the for loop above. If you wish to access the currently-rendering page/postsâ€™s variables (the variables of the post/page that has the for loop in it), use the page variable instead. Tags and Categories Jekyll has first class support for tags and categories in blog posts. Tags Tags for a post are defined in the postâ€™s front matter using either the key tag for a single entry or tags for multiple entries.  Since Jekyll expects multiple items mapped to the key tags, it will automatically split a string entry if it contains whitespace. For example, while front matter tag: classic hollywood will be processed into a singular entity "classic hollywood", front matter tags: classic hollywood will be processed into an array of entries ["classic", "hollywood"]. Irrespective of the front matter key chosen, Jekyll stores the metadata mapped to the plural key which is exposed to Liquid templates. All tags registered in the current site are exposed to Liquid templates via site.tags. Iterating over site.tags on a page will yield another array with two items, where the first item is the name of the tag and the second item being an array of posts with that tag. {% for tag in site.tags %}
  <h3>{{ tag[0] }}</h3>
  <ul>
    {% for post in tag[1] %}
      <li><a href="{{ post.url }}">{{ post.title }}</a></li>
    {% endfor %}
  </ul>
{% endfor %}
 Categories Categories of a post work similar to the tags above:  They can be defined via the front matter using keys category or categories (that follow the same logic as for tags) All categories registered in the site are exposed to Liquid templates via site.categories which can be iterated over (similar to the loop for tags above.)  The similarity between categories and tags however, ends there. Unlike tags, categories for posts can also be defined by a postâ€™s file path. Any directory above _post will be read-in as a category. For example, if a post is at path movies/horror/_posts/2019-05-21-bride-of-chucky.markdown, then movies and horror are automatically registered as categories for that post. When the post also has front matter defining categories, they just get added to the existing list if not present already. The hallmark difference between categories and tags is that categories of a post may be incorporated into the generated URL for the post, while tags cannot be. Therefore, depending on whether front matter has category: classic hollywood, or categories: classic hollywood, the example post above would have the URL as either movies/horror/classic%20hollywood/2019/05/21/bride-of-chucky.html or movies/horror/classic/hollywood/2019/05/21/bride-of-chucky.html respectively. Post excerpts You can access a snippet of a postsâ€™s content by using excerpt variable on a post. By default this is the first paragraph of content in the post, however it can be customized by setting a excerpt_separator variable in front matter or _config.yml. ---
excerpt_separator: <!--more-->
---
Excerpt with multiple paragraphs
Here's another paragraph in the excerpt.
<!--more-->
Out-of-excerpt
 Hereâ€™s an example of outputting a list of blog posts with an excerpt: <ul>
  {% for post in site.posts %}
    <li>
      <a href="{{ post.url }}">{{ post.title }}</a>
      {{ post.excerpt }}
    </li>
  {% endfor %}
</ul>
 Drafts Drafts are posts without a date in the filename. Theyâ€™re posts youâ€™re still working on and donâ€™t want to publish yet. To get up and running with drafts, create a _drafts folder in your siteâ€™s root and create your first draft: .
â”œâ”€â”€ _drafts
â”‚   â””â”€â”€ a-draft-post.md
...
 To preview your site with drafts, run jekyll serve or jekyll build with the --drafts switch. Each will be assigned the value modification time of the draft file for its date, and thus you will see currently edited drafts as the latest posts.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/posts/


rendering-process/index
-----------------------------------------------------------
Rendering Process For any Jekyll site, a build session consists of discrete phases in the following order â€” setting up plugins, reading source files, running generators, rendering templates, and finally writing files to disk. While the phases above are self-explanatory, the one phase that warrants dissection is the rendering phase. The rendering phase is further divisible into three optional stages. Every file rendered, passes through one or more of these stages as determined by the fileâ€™s content string, front matter and extension. The stages are akin to an assembly line, with the output from a stage being the input for the succeeding stage:  
Interpreting Liquid expressions in the file This stage evaluates Liquid expressions in the current file. By default, the interpretation is shallow â€” in that any Liquid expression in resulting output is not further interpreted. Moreover, any Liquid expression in the fileâ€™s front matter is left untouched. 
Unleashing the converters This stage invokes the converter mapped to the current fileâ€™s extension and converts the input string. This is when Markdown gets converted into HTML and Sass / Scss into CSS or CoffeeScript into JavaScript, etc, etc. Since this stage is determined by the fileâ€™s extension, Markdown or Sass inside a .html file will remain untouched. 
Populating the layouts By this stage, the source file is considered rendered and it will not be revisited. However, based on the fileâ€™s extension and consequently based on the front matter, it is determined whether to take the output string from the preceding stage and place into layouts or not. Whereas output from Sass files or CoffeeScript files are never placed into a layout, regular text output can go either ways based on whether a layout has been assigned via the front matter. Placement into layouts work similar to how Russian dolls encase the smaller ones within itself or how an oyster generates a pearl â€” the converted output from the preceding stage forms the core and layout(s) are successively rendered separately onto the core. 
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/rendering-process/


ruby-101/index
-----------------------------------------------------------
Ruby 101 Jekyll is written in Ruby. If youâ€™re new to Ruby, this page helps you learn some of the terminology. Gems Gems are code you can include in Ruby projects. Gems package specific functionality. You can share gems across multiple projects or with other people. Gems can perform actions like:  Converting a Ruby object to JSON Pagination Interacting with APIs such as GitHub  Jekyll is a gem. Many Jekyll plugins are also gems, including jekyll-feed, jekyll-seo-tag and jekyll-archives. Gemfile A Gemfile is a list of gems used by your site. Every Jekyll site has a Gemfile in the main folder. For a simple Jekyll site it might look something like this: source "https://rubygems.org"
gem "jekyll"
group :jekyll_plugins do
  gem "jekyll-feed"
  gem "jekyll-seo-tag"
end
 Bundler Bundler is a gem that installs all gems in your Gemfile. While you donâ€™t have to use Gemfile and bundler, it is highly recommended as it ensures youâ€™re running the same version of Jekyll and its plugins across different environments. Install Bundler using gem install bundler. You only need to install it once, not every time you create a new Jekyll project. To install gems in your Gemfile using Bundler, run the following in the directory that has the Gemfile: bundle install
bundle exec jekyll serve
 To bypass Bundler if you arenâ€™t using a Gemfile, run jekyll serve. See Using Jekyll with Bundler for more information about Bundler in Jekyll and for instructions to get up and running quickly.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/ruby-101/


static-files/index
-----------------------------------------------------------
Static Files A static file is a file that does not contain any front matter. These include images, PDFs, and other un-rendered content. Theyâ€™re accessible in Liquid via site.static_files and contain the following metadata:     Variable Description     file.path  The relative path to the file, e.g. /assets/img/image.jpg    file.modified_time  The `Time` the file was last modified, e.g. 2016-04-01 16:35:26 +0200    file.name  The string name of the file e.g. image.jpg for image.jpg    file.basename  The string basename of the file e.g. image for image.jpg    file.extname  The extension name for the file, e.g. .jpg for image.jpg      Note that in the above table, file can be anything. Itâ€™s an arbitrarily set variable used in your own logic (such as in a for loop). It isnâ€™t a global site or page variable. Add front matter to static files Although you canâ€™t directly add front matter values to static files, you can set front matter values through the defaults property in your configuration file. When Jekyll builds the site, it will use the front matter values you set. Hereâ€™s an example: In your _config.yml file, add the following values to the defaults property: defaults:
  - scope:
      path: "assets/img"
    values:
      image: true
 This assumes that your Jekyll site has a folder path of assets/img where you have images (static files) stored. When Jekyll builds the site, it will treat each image as if it had the front matter value of image: true. Suppose you want to list all your image assets as contained in assets/img. You could use this for loop to look in the static_files object and get all static files that have this front matter property: {% assign image_files = site.static_files | where: "image", true %}
{% for myimage in image_files %}
  {{ myimage.path }}
{% endfor %}
 When you build your site, the output will list the path to each file that meets this front matter condition.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/static-files/


step-by-step/01-setup/index
-----------------------------------------------------------
Step by Step Tutorial 1. Setup Welcome to Jekyllâ€™s step-by-step tutorial. The goal of this tutorial is to take you from having some front end web development experience to building your first Jekyll site from scratch â€” not relying on the default gem-based theme. Letâ€™s get into it! Installation Jekyll is a Ruby program so you need to install Ruby on your machine to begin with. Head over to the install guide and follow the instructions for your operating system. With Ruby setup you can install Jekyll by running the following in your terminal: gem install jekyll bundler
 To create a new Gemfile to list your projectâ€™s dependencies run: bundle init
 Now edit the Gemfile and add jekyll as a dependency: gem "jekyll"
 Finally run bundle to install jekyll for your project. You can now prefix all jekyll commands listed in this tutorial with bundle exec to make sure you use the jekyll version defined in your Gemfile. Create a site Itâ€™s time to create a site! Create a new directory for your site, you can name it whatever youâ€™d like. Through the rest of this tutorial weâ€™ll refer to this directory as â€œrootâ€. If youâ€™re feeling adventurous, you can also initialize a Git repository here. One of the great things about Jekyll is thereâ€™s no database. All content and site structure are files which a Git repository can version. Using a repository is completely optional but itâ€™s a great habit to get into. You can learn more about using Git by reading through the Git Handbook. Letâ€™s add your first file. Create index.html in the root with the following content: <!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Home</title>
  </head>
  <body>
    <h1>Hello World!</h1>
  </body>
</html>
 Build Jekyll is a static site generator so we need Jekyll to build the site before we can view it. There are two commands you can run in the root of your site to build it:  
jekyll build - Builds the site and outputs a static site to a directory called _site. 
jekyll serve - Does the same thing except it rebuilds any time you make a change and runs a local web server at http://localhost:4000.  When youâ€™re developing a site youâ€™ll use jekyll serve as it updates with any changes you make. Run jekyll serve and go to http://localhost:4000 in your browser. You should see â€œHello World!â€. Well, you might be thinking whatâ€™s the point in this? Jekyll just copied an HTML file from one place to another. Well patience young grasshopper, thereâ€™s still much to learn!  Setup Liquid Front Matter Layouts Includes Data Files Assets Blogging Collections Deployment 
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/step-by-step/01-setup/


step-by-step/02-liquid/index
-----------------------------------------------------------
Step by Step Tutorial 2. Liquid Liquid is where Jekyll starts to get more interesting. Liquid is a templating language which has three main parts: objects, tags and filters. Objects Objects tell Liquid where to output content. Theyâ€™re denoted by double curly braces: {{ and }}. For example: {{ page.title }}
 Outputs a variable called page.title on the page. Tags Tags create the logic and control flow for templates. They are denoted by curly braces and percent signs: {% and %}. For example: {% if page.show_sidebar %}
  <div class="sidebar">
    sidebar content
  </div>
{% endif %}
 Outputs the sidebar if page.show_sidebar is true. You can learn more about the tags available to Jekyll here. Filters Filters change the output of a Liquid object. They are used within an output and are separated by a |. For example: {{ "hi" | capitalize }}
 Outputs Hi. You can learn more about the filters available to Jekyll here. Use Liquid Now itâ€™s your turn, change the Hello World! on your page to output as lowercase: ...
<h1>{{ "Hello World!" | downcase }}</h1>
...
 To get our changes processed by Jekyll we need to add front matter to the top of the page: ---
# front matter tells Jekyll to process Liquid
---
 Our â€œHello World!â€ will now be downcased on render. It may not seem like it now, but much of Jekyllâ€™s power comes from combining Liquid with other features. In order to see the changes from downcase Liquid filter, we will need to add front matter. Thatâ€™s next. Letâ€™s keep going.  Setup Liquid Front Matter Layouts Includes Data Files Assets Blogging Collections Deployment 
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/step-by-step/02-liquid/


step-by-step/03-front-matter/index
-----------------------------------------------------------
Step by Step Tutorial 3. Front Matter Front matter is a snippet of YAML which sits between two triple-dashed lines at the top of a file. Front matter is used to set variables for the page, for example: ---
my_number: 5
---
 Front matter variables are available in Liquid under the page variable. For example to output the variable above you would use: {{ page.my_number }}
 Use front matter Letâ€™s change the <title> on your site to populate using front matter: ---
title: Home
---
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>{{ page.title }}</title>
  </head>
  <body>
    <h1>{{ "Hello World!" | downcase }}</h1>
  </body>
</html>
 Note that in order for Jekyll to process any liquid tags on your page, you must include front matter on it. The most minimal snippet of front matter you can include is: ---
---
 You may still be wondering why youâ€™d output it this way as it takes more source code than raw HTML. In this next step, youâ€™ll see why weâ€™ve been doing this.  Setup Liquid Front Matter Layouts Includes Data Files Assets Blogging Collections Deployment 
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/step-by-step/03-front-matter/


step-by-step/04-layouts/index
-----------------------------------------------------------
Step by Step Tutorial 4. Layouts Websites typically have more than one page and this website is no different. Jekyll supports Markdown as well as HTML for pages. Markdown is a great choice for pages with a simple content structure (just paragraphs, headings and images), as itâ€™s less verbose than raw HTML. Letâ€™s try it out on the next page. Create about.md in the root. For the structure you could copy index.html and modify it for the about page. The problem with doing this is duplicate code. Letâ€™s say you wanted to add a stylesheet to your site, you would have to go to each page and add it to the <head>. It might not sound so bad for a two page site, imagine doing it for 100 pages. Even simple changes will take a long time to make. Creating a layout Using a layout is a much better choice. Layouts are templates that wrap around your content. They live in a directory called _layouts. Create your first layout at _layouts/default.html with the following content: <!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>{{ page.title }}</title>
  </head>
  <body>
    {{ content }}
  </body>
</html>
 Youâ€™ll notice this is almost identical to index.html except thereâ€™s no front matter and the content of the page is replaced with a content variable. content is a special variable which has the value of the rendered content of the page itâ€™s called on. To have index.html use this layout, you can set a layout variable in front matter. The layout wraps around the content of the page so all you need in index.html is: ---
layout: default
title: Home
---
<h1>{{ "Hello World!" | downcase }}</h1>
 After doing this, the output will be exactly the same as before. Note that you can access the page front matter from the layout. In this case title is set in the index pageâ€™s front matter but is output in the layout. About page Back to the about page, instead of copying from index.html, you can use the layout. Add the following to about.md: ---
layout: default
title: About
---
# About page
This page tells you a little bit about me.
 Open http://localhost:4000/about.html in your browser and view your new page. Congratulations, you now have a two page website! But how do you navigate from one page to another? Keep reading to find out.  Setup Liquid Front Matter Layouts Includes Data Files Assets Blogging Collections Deployment 
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/step-by-step/04-layouts/


step-by-step/05-includes/index
-----------------------------------------------------------
Step by Step Tutorial 5. Includes The site is coming together; however, thereâ€™s no way to navigate between pages. Letâ€™s fix that. Navigation should be on every page so adding it to your layout is the correct place to do this. Instead of adding it directly to the layout, letâ€™s use this as an opportunity to learn about includes. Include tag The include tag allows you to include content from another file stored in an _includes folder. Includes are useful for having a single source for source code that repeats around the site or for improving the readability. Navigation source code can get complex, so sometimes itâ€™s nice to move it into an include. Include usage Create a file for the navigation at _includes/navigation.html with the following content: <nav>
  <a href="/">Home</a>
  <a href="/about.html">About</a>
</nav>
 Try using the include tag to add the navigation to _layouts/default.html: <!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>{{ page.title }}</title>
  </head>
  <body>
    {% include navigation.html %}
    {{ content }}
  </body>
</html>
 Open http://localhost:4000 in your browser and try switching between the pages. Current page highlighting Letâ€™s take this a step further and highlight the current page in the navigation. _includes/navigation.html needs to know the URL of the page itâ€™s inserted into so it can add styling. Jekyll has useful variables available, one of which is page.url. Using page.url you can check if each link is the current page and color it red if true: <nav>
  <a href="/" {% if page.url == "/" %}style="color: red;"{% endif %}>
    Home
  </a>
  <a href="/about.html" {% if page.url == "/about.html" %}style="color: red;"{% endif %}>
    About
  </a>
</nav>
 Take a look at http://localhost:4000 and see your red link for the current page. Thereâ€™s still a lot of repetition here if you wanted to add a new item to the navigation or change the highlight color. In the next step weâ€™ll address this.  Setup Liquid Front Matter Layouts Includes Data Files Assets Blogging Collections Deployment 
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/step-by-step/05-includes/


step-by-step/06-data-files/index
-----------------------------------------------------------
Step by Step Tutorial 6. Data Files Jekyll supports loading data from YAML, JSON, and CSV files located in a _data directory. Data files are a great way to separate content from source code to make the site easier to maintain. In this step youâ€™ll store the contents of the navigation in a data file and then iterate over it in the navigation include. Data file usage YAML is a format thatâ€™s common in the Ruby ecosystem. Youâ€™ll use it to store an array of navigation items each with a name and link. Create a data file for the navigation at _data/navigation.yml with the following: - name: Home
  link: /
- name: About
  link: /about.html
 Jekyll makes this data file available to you at site.data.navigation. Instead of outputting each link in _includes/navigation.html, now you can iterate over the data file instead: <nav>
  {% for item in site.data.navigation %}
    <a href="{{ item.link }}" {% if page.url == item.link %}style="color: red;"{% endif %}>
      {{ item.name }}
    </a>
  {% endfor %}
</nav>
 The output will be exactly the same. The difference is youâ€™ve made it easier to add new navigation items and change the HTML structure. What good is a site without CSS, JS and images? Letâ€™s look at how to handle assets in Jekyll.  Setup Liquid Front Matter Layouts Includes Data Files Assets Blogging Collections Deployment 
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/step-by-step/06-data-files/


step-by-step/07-assets/index
-----------------------------------------------------------
Step by Step Tutorial 7. Assets Using CSS, JS, images and other assets is straightforward with Jekyll. Place them in your site folder and theyâ€™ll copy across to the built site. Jekyll sites often use this structure to keep assets organized: .
â”œâ”€â”€ assets
â”‚   â”œâ”€â”€ css
â”‚   â”œâ”€â”€ images
â”‚   â””â”€â”€ js
...
 So, from your assets folder, create folders called css, images and js. Additionally, directly under the root create another folder called â€˜_sassâ€™, which you will need shortly. Sass Inlining the styles used in _includes/navigation.html(adding or configuring within the same file) is not a best practice. Instead, letâ€™s style the current page by defining our first class in a new css file instead. To do this, refer to the class (that you will configure in the next parts of this step) from within the navigation.html file by removing the code you added earlier (to color the current link red) and inserting the following code: <nav>
  {% for item in site.data.navigation %}
    <a href="{{ item.link }}" {% if page.url == item.link %}class="current"{% endif %}>{{ item.name }}</a>
  {% endfor %}
</nav>
 You could use a standard CSS file for styling, weâ€™re going to take it a step further by using Sass. Sass is a fantastic extension to CSS baked right into Jekyll. First create a Sass file at assets/css/styles.scss with the following content: ---
---
@import "main";
 The empty front matter at the top tells Jekyll it needs to process the file. The @import "main" tells Sass to look for a file called main.scss in the sass directory (_sass/) by default which you already created directly under the root folder of your website). At this stage youâ€™ll just have a main css file. For larger projects, this is a great way to keep your CSS organized. Create the current class mentioned above in order to color the current link green. Create a Sass file at _sass/main.scss with the following content: .current {
  color: green;
}
 Youâ€™ll need to reference the stylesheet in your layout. Open _layouts/default.html and add the stylesheet to the <head>: <!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>{{ page.title }}</title>
    <link rel="stylesheet" href="/assets/css/styles.css">
  </head>
  <body>
    {% include navigation.html %}
    {{ content }}
  </body>
</html>
 The styles.css referenced here is generated by Jekyll from the styles.scss you created earlier in assets/css/. Load up http://localhost:4000 and check that the active link in the navigation is green. Next weâ€™re looking at one of Jekyllâ€™s most popular features, blogging.  Setup Liquid Front Matter Layouts Includes Data Files Assets Blogging Collections Deployment 
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/step-by-step/07-assets/


step-by-step/08-blogging/index
-----------------------------------------------------------
Step by Step Tutorial 8. Blogging You might be wondering how you can have a blog without a database. In true Jekyll style, blogging is powered by text files only. Posts Blog posts live in a folder called _posts. The filename for posts have a special format: the publish date, then a title, followed by an extension. Create your first post at _posts/2018-08-20-bananas.md with the following content: ---
layout: post
author: jill
---
A banana is an edible fruit â€“ botanically a berry â€“ produced by several kinds
of large herbaceous flowering plants in the genus Musa.
In some countries, bananas used for cooking may be called "plantains",
distinguishing them from dessert bananas. The fruit is variable in size, color,
and firmness, but is usually elongated and curved, with soft flesh rich in
starch covered with a rind, which may be green, yellow, red, purple, or brown
when ripe.
 This is like the about.md you created before except it has an author and a different layout. author is a custom variable, itâ€™s not required and could have been named something like creator. Layout The post layout doesnâ€™t exist so youâ€™ll need to create it at _layouts/post.html with the following content: ---
layout: default
---
<h1>{{ page.title }}</h1>
<p>{{ page.date | date_to_string }} - {{ page.author }}</p>
{{ content }}
 This is an example of layout inheritance. The post layout outputs the title, date, author and content body which is wrapped by the default layout. Also note the date_to_string filter, this formats a date into a nicer format. List posts Thereâ€™s currently no way to navigate to the blog post. Typically a blog has a page which lists all the posts, letâ€™s do that next. Jekyll makes posts available at site.posts. Create blog.html in your root (/blog.html) with the following content: ---
layout: default
title: Blog
---
<h1>Latest Posts</h1>
<ul>
  {% for post in site.posts %}
    <li>
      <h2><a href="{{ post.url }}">{{ post.title }}</a></h2>
      {{ post.excerpt }}
    </li>
  {% endfor %}
</ul>
 Thereâ€™s a few things to note with this code:  
post.url is automatically set by Jekyll to the output path of the post 
post.title is pulled from the post filename and can be overridden by setting title in front matter 
post.excerpt is the first paragraph of content by default  You also need a way to navigate to this page through the main navigation. Open _data/navigation.yml and add an entry for the blog page: - name: Home
  link: /
- name: About
  link: /about.html
- name: Blog
  link: /blog.html
 More posts A blog isnâ€™t very exciting with a single post. Add a few more: _posts/2018-08-21-apples.md: ---
layout: post
author: jill
---
An apple is a sweet, edible fruit produced by an apple tree.
Apple trees are cultivated worldwide, and are the most widely grown species in
the genus Malus. The tree originated in Central Asia, where its wild ancestor,
Malus sieversii, is still found today. Apples have been grown for thousands of
years in Asia and Europe, and were brought to North America by European
colonists.
 _posts/2018-08-22-kiwifruit.md: ---
layout: post
author: ted
---
Kiwifruit (often abbreviated as kiwi), or Chinese gooseberry is the edible
berry of several species of woody vines in the genus Actinidia.
The most common cultivar group of kiwifruit is oval, about the size of a large
hen's egg (5â€“8 cm (2.0â€“3.1 in) in length and 4.5â€“5.5 cm (1.8â€“2.2 in) in
diameter). It has a fibrous, dull greenish-brown skin and bright green or
golden flesh with rows of tiny, black, edible seeds. The fruit has a soft
texture, with a sweet and unique flavor.
 Open http://localhost:4000 and have a look through your blog posts. Next weâ€™ll focus on creating a page for each post author.  Setup Liquid Front Matter Layouts Includes Data Files Assets Blogging Collections Deployment 
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/step-by-step/08-blogging/


step-by-step/09-collections/index
-----------------------------------------------------------
Step by Step Tutorial 9. Collections Letâ€™s look at fleshing out authors so each author has their own page with a blurb and the posts theyâ€™ve published. To do this youâ€™ll use collections. Collections are similar to posts except the content doesnâ€™t have to be grouped by date. Configuration To set up a collection you need to tell Jekyll about it. Jekyll configuration happens in a file called _config.yml (by default). Create _config.yml in the root with the following: collections:
  authors:
 To (re)load the configuration, restart the jekyll server. Press Ctrl+C in your terminal to stop the server, and then jekyll serve to restart it. Add authors Documents (the items in a collection) live in a folder in the root of the site named _*collection_name*. In this case, _authors. Create a document for each author: _authors/jill.md: ---
short_name: jill
name: Jill Smith
position: Chief Editor
---
Jill is an avid fruit grower based in the south of France.
 _authors/ted.md: ---
short_name: ted
name: Ted Doe
position: Writer
---
Ted has been eating fruit since he was baby.
 Staff page Letâ€™s add a page which lists all the authors on the site. Jekyll makes the collection available at site.authors. Create staff.html and iterate over site.authors to output all the staff: ---
layout: default
title: Staff
---
<h1>Staff</h1>
<ul>
  {% for author in site.authors %}
    <li>
      <h2>{{ author.name }}</h2>
      <h3>{{ author.position }}</h3>
      <p>{{ author.content | markdownify }}</p>
    </li>
  {% endfor %}
</ul>
 Since the content is markdown, you need to run it through the markdownify filter. This happens automatically when outputting using {{ content }} in a layout. You also need a way to navigate to this page through the main navigation. Open _data/navigation.yml and add an entry for the staff page: - name: Home
  link: /
- name: About
  link: /about.html
- name: Blog
  link: /blog.html
- name: Staff
  link: /staff.html
 Output a page By default, collections do not output a page for documents. In this case we want each author to have their own page so letâ€™s tweak the collection configuration. Open _config.yml and add output: true to the author collection configuration: collections:
  authors:
    output: true
 Restart the jekyll server once more for the configuration changes to take effect. You can link to the output page using author.url. Add the link to the staff.html page: ---
layout: default
title: Staff
---
<h1>Staff</h1>
<ul>
  {% for author in site.authors %}
    <li>
      <h2><a href="{{ author.url }}">{{ author.name }}</a></h2>
      <h3>{{ author.position }}</h3>
      <p>{{ author.content | markdownify }}</p>
    </li>
  {% endfor %}
</ul>
 Just like posts youâ€™ll need to create a layout for authors. Create _layouts/author.html with the following content: ---
layout: default
---
<h1>{{ page.name }}</h1>
<h2>{{ page.position }}</h2>
{{ content }}
 Front matter defaults Now you need to configure the author documents to use the author layout. You could do this in the front matter like we have previously but thatâ€™s getting repetitive. What you really want is all posts to automatically have the post layout, authors to have author and everything else to use the default. You can achieve this by using front matter defaults in _config.yml. You set a scope of what the default applies to, then the default front matter youâ€™d like. Add defaults for layouts to your _config.yml, collections:
  authors:
    output: true
defaults:
  - scope:
      path: ""
      type: "authors"
    values:
      layout: "author"
  - scope:
      path: ""
      type: "posts"
    values:
      layout: "post"
  - scope:
      path: ""
    values:
      layout: "default"
 Now you can remove layout from the front matter of all pages and posts. Note that any time you update _config.yml youâ€™ll need to restart Jekyll for the changes to take effect. List authorâ€™s posts Letâ€™s list the posts an author has published on their page. To do this you need to match the author short_name to the post author. You use this to filter the posts by author. Iterate over this filtered list in _layouts/author.html to output the authorâ€™s posts: ---
layout: default
---
<h1>{{ page.name }}</h1>
<h2>{{ page.position }}</h2>
{{ content }}
<h2>Posts</h2>
<ul>
  {% assign filtered_posts = site.posts | where: 'author', page.short_name %}
  {% for post in filtered_posts %}
    <li><a href="{{ post.url }}">{{ post.title }}</a></li>
  {% endfor %}
</ul>
 Link to authors page The posts have a reference to the author so letâ€™s link it to the authorâ€™s page. You can do this using a similar filtering technique in _layouts/post.html: ---
layout: default
---
<h1>{{ page.title }}</h1>
<p>
  {{ page.date | date_to_string }}
  {% assign author = site.authors | where: 'short_name', page.author | first %}
  {% if author %}
    - <a href="{{ author.url }}">{{ author.name }}</a>
  {% endif %}
</p>
{{ content }}
 Open up http://localhost:4000 and have a look at the staff page and the author links on posts to check everything is linked together correctly. In the next and final step of this tutorial, weâ€™ll add polish to the site and get it ready for a production deployment.  Setup Liquid Front Matter Layouts Includes Data Files Assets Blogging Collections Deployment 
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/step-by-step/09-collections/


step-by-step/10-deployment/index
-----------------------------------------------------------
Step by Step Tutorial 10. Deployment In this final step weâ€™ll get the site ready for production. Gemfile Itâ€™s good practice to have a Gemfile for your site. This ensures the version of Jekyll and other gems remains consistent across different environments. Create a Gemfile in the root. The file should be called â€˜Gemfileâ€™ and should not have any extension. You can create a Gemfile with Bundler and then add the jekyll gem: bundle init
bundle add jekyll
 Your file should look something like: # frozen_string_literal: true
source "https://rubygems.org"
gem "jekyll"
 Bundler installs the gems and creates a Gemfile.lock which locks the current gem versions for a future bundle install. If you ever want to update your gem versions you can run bundle update. When using a Gemfile, youâ€™ll run commands like jekyll serve with bundle exec prefixed. So the full command is: bundle exec jekyll serve
 This restricts your Ruby environment to only use gems set in your Gemfile. Plugins Jekyll plugins allow you to create custom generated content specific to your site. Thereâ€™s many plugins available or you can even write your own. There are three official plugins which are useful on almost any Jekyll site:  
jekyll-sitemap - Creates a sitemap file to help search engines index content 
jekyll-feed - Creates an RSS feed for your posts 
jekyll-seo-tag - Adds meta tags to help with SEO  To use these first you need to add them to your Gemfile. If you put them in a jekyll_plugins group theyâ€™ll automatically be required into Jekyll: source 'https://rubygems.org'
gem 'jekyll'
group :jekyll_plugins do
  gem 'jekyll-sitemap'
  gem 'jekyll-feed'
  gem 'jekyll-seo-tag'
end
 Then add these lines to your _config.yml: plugins:
  - jekyll-feed
  - jekyll-sitemap
  - jekyll-seo-tag
 Now install them by running a bundle update. jekyll-sitemap doesnâ€™t need any setup, it will create your sitemap on build. For jekyll-feed and jekyll-seo-tag you need to add tags to _layouts/default.html: <!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>{{ page.title }}</title>
    <link rel="stylesheet" href="/assets/css/styles.css">
    {% feed_meta %}
    {% seo %}
  </head>
  <body>
    {% include navigation.html %}
    {{ content }}
  </body>
</html>
 Restart your Jekyll server and check these tags are added to the <head>. Environments Sometimes you might want to output something in production but not in development. Analytics scripts are the most common example of this. To do this you can use environments. You can set the environment by using the JEKYLL_ENV environment variable when running a command. For example: JEKYLL_ENV=production bundle exec jekyll build
 By default JEKYLL_ENV is development. The JEKYLL_ENV is available to you in liquid using jekyll.environment. So to only output the analytics script on production you would do the following: {% if jekyll.environment == "production" %}
  <script src="my-analytics-script.js"></script>
{% endif %}
 Deployment The final step is to get the site onto a production server. The most basic way to do this is to run a production build: JEKYLL_ENV=production bundle exec jekyll build
 And copy the contents of _site to your server. A better way is to automate this process using a CI or 3rd party. Wrap up That brings us to the end of this step-by-step tutorial and the beginning of your Jekyll journey!  Come say hi to the community forums
 Help us make Jekyll better by contributing
 Keep building Jekyll sites!   Setup Liquid Front Matter Layouts Includes Data Files Assets Blogging Collections Deployment 
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/step-by-step/10-deployment/


structure/index
-----------------------------------------------------------
Directory Structure A basic Jekyll site usually looks something like this: .
â”œâ”€â”€ _config.yml
â”œâ”€â”€ _data
â”‚   â””â”€â”€ members.yml
â”œâ”€â”€ _drafts
â”‚   â”œâ”€â”€ begin-with-the-crazy-ideas.md
â”‚   â””â”€â”€ on-simplicity-in-technology.md
â”œâ”€â”€ _includes
â”‚   â”œâ”€â”€ footer.html
â”‚   â””â”€â”€ header.html
â”œâ”€â”€ _layouts
â”‚   â”œâ”€â”€ default.html
â”‚   â””â”€â”€ post.html
â”œâ”€â”€ _posts
â”‚   â”œâ”€â”€ 2007-10-29-why-every-programmer-should-play-nethack.md
â”‚   â””â”€â”€ 2009-04-26-barcamp-boston-4-roundup.md
â”œâ”€â”€ _sass
â”‚   â”œâ”€â”€ _base.scss
â”‚   â””â”€â”€ _layout.scss
â”œâ”€â”€ _site
â”œâ”€â”€ .jekyll-metadata
â””â”€â”€ index.html # can also be an 'index.md' with valid front matter
  Directory structure of Jekyll sites using gem-based themes  Since version 3.2 , a new Jekyll project bootstrapped with jekyll new uses gem-based themes to define the look of the site. This results in a lighter default directory structure: _layouts, _includes and _sass are stored in the theme-gem, by default.   minima is the current default theme, and bundle info minima will show you where minima theme's files are stored on your computer.   An overview of what each of these does:     File / Directory Description      _config.yml    Stores configuration data. Many of these options can be specified from the command line executable but itâ€™s easier to specify them here so you donâ€™t have to remember them.      _drafts    Drafts are unpublished posts. The format of these files is without a date: title.MARKUP. Learn how to  work with drafts.      _includes    These are the partials that can be mixed and matched by your layouts and posts to facilitate reuse. The liquid tag {% include file.ext %} can be used to include the partial in _includes/file.ext.      _layouts    These are the templates that wrap posts. Layouts are chosen on a post-by-post basis in the front matter, which is described in the next section. The liquid tag {{ content }} is used to inject content into the web page.      _posts    Your dynamic content, so to speak. The naming convention of these files is important, and must follow the format: YEAR-MONTH-DAY-title.MARKUP. The permalinks can be customized for each post, but the date and markup language are determined solely by the file name.      _data    Well-formatted site data should be placed here. The Jekyll engine will autoload all data files (using either the .yml, .yaml, .json, .csv or .tsv formats and extensions) in this directory, and they will be accessible via `site.data`. If there's a file members.yml under the directory, then you can access contents of the file through site.data.members.      _sass    These are sass partials that can be imported into your main.scss which will then be processed into a single stylesheet main.css that defines the styles to be used by your site. Learn how to work with assets.      _site    This is where the generated site will be placed (by default) once Jekyll is done transforming it. Itâ€™s probably a good idea to add this to your .gitignore file.      .jekyll-metadata    This helps Jekyll keep track of which files have not been modified since the site was last built, and which files will need to be regenerated on the next build. This file will not be included in the generated site. Itâ€™s probably a good idea to add this to your .gitignore file.      index.html or index.md and other HTML, Markdown files    Provided that the file has a front matter section, it will be transformed by Jekyll. The same will happen for any .html, .markdown, .md, or .textile file in your siteâ€™s root directory or directories not listed above.      Other Files/Folders    Except for the special cases listed above, every other directory and fileâ€”such as css and images folders, favicon.ico files, and so forthâ€”will be copied verbatim to the generated site. There are plenty of sites already using Jekyll if youâ€™re curious to see how theyâ€™re laid out.       Every file or directory beginning with the following characters: ., _ , # or ~ in the source directory will not be included in the destination folder. Such paths will have to be explicitly specified via the config file in the include directive to make sure theyâ€™re copied over: include:
 - _pages
 - .htaccess

    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/structure/


themes/index
-----------------------------------------------------------
Themes Jekyll has an extensive theme system that allows you to leverage community-maintained templates and styles to customize your siteâ€™s presentation. Jekyll themes specify plugins and package up assets, layouts, includes, and stylesheets in a way that can be overridden by your siteâ€™s content. Pick up a theme You can find and preview themes on different galleries:  GitHub.com #jekyll-theme repos jamstackthemes.dev jekyllthemes.org jekyllthemes.io jekyll-themes.com  See also: resources. Understanding gem-based themes When you create a new Jekyll site (by running the jekyll new <PATH> command), Jekyll installs a site that uses a gem-based theme called Minima. With gem-based themes, some of the siteâ€™s directories (such as the assets, _layouts, _includes, and _sass directories) are stored in the themeâ€™s gem, hidden from your immediate view. Yet all of the necessary directories will be read and processed during Jekyllâ€™s build process. In the case of Minima, you see only the following files in your Jekyll site directory: .
â”œâ”€â”€ Gemfile
â”œâ”€â”€ Gemfile.lock
â”œâ”€â”€ _config.yml
â”œâ”€â”€ _posts
â”‚   â””â”€â”€ 2016-12-04-welcome-to-jekyll.markdown
â”œâ”€â”€ about.markdown
â””â”€â”€ index.markdown
 The Gemfile and Gemfile.lock files are used by Bundler to keep track of the required gems and gem versions you need to build your Jekyll site. Gem-based themes make it easier for theme developers to make updates available to anyone who has the theme gem. When thereâ€™s an update, theme developers push the update to RubyGems. If you have the theme gem, you can (if you desire) run bundle update to update all gems in your project. Or you can run bundle update <THEME>, replacing <THEME> with the theme name, such as minima, to just update the theme gem. Any new files or updates the theme developer has made (such as to stylesheets or includes) will be pulled into your project automatically. The goal of gem-based themes is to allow you to get all the benefits of a robust, continually updated theme without having all the themeâ€™s files getting in your way and over-complicating what might be your primary focus: creating content. Overriding theme defaults Jekyll themes set default layouts, includes, and stylesheets. However, you can override any of the theme defaults with your own site content. To replace layouts or includes in your theme, make a copy in your _layouts or _includes directory of the specific file you wish to modify, or create the file from scratch giving it the same name as the file you wish to override. For example, if your selected theme has a page layout, you can override the themeâ€™s layout by creating your own page layout in the _layouts directory (that is, _layouts/page.html). To locate a themeâ€™s files on your computer:   Run bundle info --path followed by the name of the themeâ€™s gem, e.g., bundle info --path minima for Jekyllâ€™s default theme. This returns the location of the gem-based theme files. For example, the Minima themeâ€™s files might be located in /usr/local/lib/ruby/gems/2.6.0/gems/minima-2.5.1 on macOS.   Open the themeâ€™s directory in Finder or Explorer: # On MacOS
open $(bundle info --path minima)
# On Windows
# First get the gem's installation path:
#
#   bundle info --path minima
#   => C:/Ruby26-x64/lib/ruby/gems/2.7.2/gems/minima-2.5.1
#
# then invoke explorer with above path, substituting `/` with `\`
explorer C:\Ruby26-x64\lib\ruby\gems\2.7.2\gems\minima-2.5.1
# On Linux
xdg-open $(bundle info --path minima)
 A Finder or Explorer window opens showing the themeâ€™s files and directories. The Minima theme gem contains these files: .
â”œâ”€â”€ LICENSE.txt
â”œâ”€â”€ README.md
â”œâ”€â”€ _includes
â”‚   â”œâ”€â”€ disqus_comments.html
â”‚   â”œâ”€â”€ footer.html
â”‚   â”œâ”€â”€ google-analytics.html
â”‚   â”œâ”€â”€ head.html
â”‚   â”œâ”€â”€ header.html
â”‚   â”œâ”€â”€ icon-github.html
â”‚   â”œâ”€â”€ icon-github.svg
â”‚   â”œâ”€â”€ icon-twitter.html
â”‚   â””â”€â”€ icon-twitter.svg
â”œâ”€â”€ _layouts
â”‚   â”œâ”€â”€ default.html
â”‚   â”œâ”€â”€ home.html
â”‚   â”œâ”€â”€ page.html
â”‚   â””â”€â”€ post.html
â”œâ”€â”€ _sass
â”‚   â”œâ”€â”€ minima
â”‚   â”‚   â”œâ”€â”€ _base.scss
â”‚   â”‚   â”œâ”€â”€ _layout.scss
â”‚   â”‚   â””â”€â”€ _syntax-highlighting.scss
â”‚   â””â”€â”€ minima.scss
â””â”€â”€ assets
    â””â”€â”€ main.scss
   With a clear understanding of the themeâ€™s files, you can now override any theme file by creating a similarly named file in your Jekyll site directory. Letâ€™s say, for a second example, you want to override Minimaâ€™s footer. In your Jekyll site, create an _includes folder and add a file in it called footer.html. Jekyll will now use your siteâ€™s footer.html file instead of the footer.html file from the Minima theme gem. To modify any stylesheet you must take the extra step of also copying the main sass file (_sass/minima.scss in the Minima theme) into the _sass directory in your siteâ€™s source. Jekyll will look first to your siteâ€™s content before looking to the themeâ€™s defaults for any requested file in the following folders:  /assets /_layouts /_includes /_sass  Note that making copies of theme files will prevent you from receiving any theme updates on those files. An alternative, to continue getting theme updates on all stylesheets, is to use higher specificity CSS selectors in your own additional, originally named CSS files. Refer to your selected themeâ€™s documentation and source repository for more information on which files you can override. Converting gem-based themes to regular themes Suppose you want to get rid of the gem-based theme and convert it to a regular theme, where all files are present in your Jekyll site directory, with nothing stored in the theme gem. To do this, copy the files from the theme gemâ€™s directory into your Jekyll site directory. (For example, copy them to /myblog if you created your Jekyll site at /myblog. See the previous section for details.) Then you must tell Jekyll about the plugins that were referenced by the theme. You can find these plugins in the themeâ€™s gemspec file as runtime dependencies. If you were converting the Minima theme, for example, you might see: spec.add_runtime_dependency "jekyll-feed", "~> 0.12"
spec.add_runtime_dependency "jekyll-seo-tag", "~> 2.6"
 You should include these references in the Gemfile in one of two ways. You could list them individually in both Gemfile and _config.yml. # ./Gemfile
gem "jekyll-feed", "~> 0.12"
gem "jekyll-seo-tag", "~> 2.6"
 # ./_config.yml
plugins:
  - jekyll-feed
  - jekyll-seo-tag
 Or you could list them explicitly as Jekyll plugins in your Gemfile, and not update _config.yml, like this: # ./Gemfile
group :jekyll_plugins do
  gem "jekyll-feed", "~> 0.12"
  gem "jekyll-seo-tag", "~> 2.6"
end
 Either way, donâ€™t forget to bundle update. If youâ€™re publishing on GitHub Pages you should update only your _config.yml as GitHub Pages doesnâ€™t load plugins via Bundler. Finally, remove references to the theme gem in Gemfile and configuration. For example, to remove minima:  Open Gemfile and remove gem "minima", "~> 2.5". Open _config.yml and remove theme: minima.  Now bundle update will no longer get updates for the theme gem. Installing a gem-based theme The jekyll new <PATH> command isnâ€™t the only way to create a new Jekyll site with a gem-based theme. You can also find gem-based themes online and incorporate them into your Jekyll project. For example, search for jekyll theme on RubyGems to find other gem-based themes. (Note that not all themes are using jekyll-theme as a convention in the theme name.) To install a gem-based theme:   Add the theme gem to your siteâ€™s Gemfile: # ./Gemfile
# This is an example, declare the theme gem you want to use here
gem "jekyll-theme-minimal"
 Or if youâ€™ve started with the jekyll new command, replace gem "minima", "~> 2.0" with the gem you want, e.g: # ./Gemfile
- gem "minima", "~> 2.5"
+ gem "jekyll-theme-minimal"
   Install the theme: bundle install
   Add the following to your siteâ€™s _config.yml to activate the theme: theme: jekyll-theme-minimal
   Build your site: bundle exec jekyll serve
   You can have multiple themes listed in your siteâ€™s Gemfile, but only one theme can be selected in your siteâ€™s _config.yml. If youâ€™re publishing your Jekyll site on GitHub Pages, note that GitHub Pages supports only some gem-based themes. GitHub Pages also supports using any theme hosted on GitHub using the remote_theme configuration as if it were a gem-based theme. Creating a gem-based theme If youâ€™re a Jekyll theme developer (rather than a consumer of themes), you can package up your theme in RubyGems and allow users to install it through Bundler. If youâ€™re unfamiliar with creating Ruby gems, donâ€™t worry. Jekyll will help you scaffold a new theme with the new-theme command. Run jekyll new-theme with the theme name as an argument. Here is an example: jekyll new-theme jekyll-theme-awesome
    create /path/to/jekyll-theme-awesome/_layouts
    create /path/to/jekyll-theme-awesome/_includes
    create /path/to/jekyll-theme-awesome/_sass
    create /path/to/jekyll-theme-awesome/_layouts/page.html
    create /path/to/jekyll-theme-awesome/_layouts/post.html
    create /path/to/jekyll-theme-awesome/_layouts/default.html
    create /path/to/jekyll-theme-awesome/Gemfile
    create /path/to/jekyll-theme-awesome/jekyll-theme-awesome.gemspec
    create /path/to/jekyll-theme-awesome/README.md
    create /path/to/jekyll-theme-awesome/LICENSE.txt
    initialize /path/to/jekyll-theme-awesome/.git
    create /path/to/jekyll-theme-awesome/.gitignore
Your new Jekyll theme, jekyll-theme-awesome, is ready for you in /path/to/jekyll-theme-awesome!
For help getting started, read /path/to/jekyll-theme-awesome/README.md.
 Add your template files in the corresponding folders. Then complete the .gemspec and the README files according to your needs. Layouts and includes Theme layouts and includes work just like they work in any Jekyll site. Place layouts in your themeâ€™s /_layouts folder, and place includes in your themes /_includes folder. For example, if your theme has a /_layouts/page.html file, and a page has layout: page in its front matter, Jekyll will first look to the siteâ€™s _layouts folder for the page layout, and if none exists, will use your themeâ€™s page layout. Assets Any file in /assets will be copied over to the userâ€™s site upon build unless they have a file with the same relative path. You can ship any kind of asset here: SCSS, an image, a webfont, etc. These files behave like pages and static files in Jekyll:  If the file has front matter at the top, it will be rendered. If the file does not have front matter, it will simply be copied over into the resulting site.  This allows theme creators to ship a default /assets/styles.scss file which their layouts can depend on as /assets/styles.css. All files in /assets will be output into the compiled site in the /assets folder just as youâ€™d expect from using Jekyll on your sites. Stylesheets Your themeâ€™s stylesheets should be placed in your themeâ€™s _sass folder, again, just as you would when authoring a Jekyll site. _sass
â””â”€â”€ jekyll-theme-awesome.scss
 Your themeâ€™s styles can be included in the userâ€™s stylesheet using the @import directive. @import "{{ site.theme }}";
 Theme-gem dependencies3.5.0  Jekyll will automatically require all whitelisted runtime_dependencies of your theme-gem even if theyâ€™re not explicitly included under the plugins array in the siteâ€™s config file. (Note: whitelisting is only required when building or serving with the --safe option.) With this, the end-user need not keep track of the plugins required to be included in their config file for their theme-gem to work as intended. Pre-configuring Theme-gems4.0  Jekyll will read-in a _config.yml at the root of the theme-gem and merge its data into the siteâ€™s existing configuration data. But unlike other entities loaded from within the theme, loading the config file comes with a few restrictions, as summarized below:  Jekyllâ€™s default settings cannot be overridden by a theme-config. That ball is still in the userâ€™s court.  The theme-config-file cannot be a symlink, irrespective of safe mode and whether the file pointed to by the symlink is a legitimate file within the theme-gem. The theme-config should be a set of key-value pairs. An empty config file, a config file that simply lists items under a key, or a config file with just a simple string of text will simply be ignored silently. Users will not get a warning or any log output regarding this discrepancy. Any settings defined by the theme-config can be overridden by the user.  While this feature is to enable easier adoption of a theme, the restrictions ensure that a theme-config cannot affect the build in a concerning manner. Any plugins required by the theme will have to be listed manually by the user or provided by the themeâ€™s gemspec file. This feature will let the theme-gem to work with theme-specific config variables out-of-the-box. Documenting your theme Your theme should include a /README.md file, which explains how site authors can install and use your theme. What layouts are included? What includes? Do they need to add anything special to their siteâ€™s configuration file? Adding a screenshot Themes are visual. Show users what your theme looks like by including a screenshot as /screenshot.png within your themeâ€™s repository where it can be retrieved programmatically. You can also include this screenshot within your themeâ€™s documentation. Previewing your theme To preview your theme as youâ€™re authoring it, it may be helpful to add dummy content in, for example, /index.html and /page.html files. This will allow you to use the jekyll build and jekyll serve commands to preview your theme, just as youâ€™d preview a Jekyll site. If you do preview your theme locally, be sure to add /_site to your themeâ€™s .gitignore file to prevent the compiled site from also being included when you distribute your theme. Publishing your theme Themes are published via RubyGems.org. You will need a RubyGems account, which you can create for free.   First, you need to have it in a git repository: git init # Only the first time
git add -A
git commit -m "Init commit"
   Next, package your theme, by running the following command, replacing jekyll-theme-awesome with the name of your theme: gem build jekyll-theme-awesome.gemspec
   Finally, push your packaged theme up to the RubyGems service, by running the following command, again replacing jekyll-theme-awesome with the name of your theme: gem push jekyll-theme-awesome-*.gem
   To release a new version of your theme, update the version number in the gemspec file, ( jekyll-theme-awesome.gemspec in this example ), and then repeat Steps 1 - 3 above. We recommend that you follow Semantic Versioning while bumping your theme-version.  
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/themes/


troubleshooting/index
-----------------------------------------------------------
Troubleshooting If you ever run into problems installing or using Jekyll, here are a few tips that might be of help. If the problem youâ€™re experiencing isnâ€™t covered below, please check out our other help resources as well.  Installation Problems Problems running Jekyll Base-URL Problems Configuration problems Markup Problems Production Problems  Installation Problems If you encounter errors during gem installation, you may need to install the header files for compiling extension modules for Ruby 2.x This can be done on Ubuntu or Debian by running: sudo apt-get install ruby2.6-dev
 On Red Hat, CentOS, and Fedora systems you can do this by running: sudo yum install ruby-devel
 On Arch Linux you need to run: sudo pacman -S ruby-ffi
 On Ubuntu if you get stuck after bundle exec jekyll serve and see error messages like Could not locate Gemfile or .bundle/ directory, itâ€™s likely because all requirements have not been fully met. Recent stock Ubuntu distributions require the installation of both the ruby and ruby-all-dev packages: sudo apt-get install ruby ruby-all-dev
 On NearlyFreeSpeech you need to run the following commands before installing Jekyll: export GEM_HOME=/home/private/gems
export GEM_PATH=/home/private/gems:/usr/local/lib/ruby/gems/1.8/
export PATH=$PATH:/home/private/gems/bin
export RB_USER_INSTALL='true'
 To install RubyGems on Gentoo: sudo emerge -av dev-ruby/rubygems
 On Windows, you may need to install RubyInstaller DevKit. On Android (with Termux) you can install all requirements by running: apt update && apt install libffi-dev clang ruby-dev make
 On macOS, you may need to update RubyGems (using sudo only if necessary): gem update --system
 If you still have issues, you can download and install new Command Line Tools (such as gcc) using the following command: xcode-select --install
 which may allow you to install native gems using this command (again, using sudo only if necessary): gem install jekyll
 Note that upgrading macOS does not automatically upgrade Xcode itself (that can be done separately via the App Store), and having an out-of-date Xcode.app can interfere with the command line tools downloaded above. If you run into this issue, upgrade Xcode and install the upgraded Command Line Tools. Running Jekyll as Non-Superuser (no sudo!) On most flavors of Linux, macOS, and Bash on Ubuntu on Windows, it is possible to run Jekyll as a non-superuser and without having to install gems to system-wide locations by adding the following lines to the end of your .bashrc file: # Ruby exports
export GEM_HOME=$HOME/gems
export PATH=$HOME/gems/bin:$PATH
 This tells gem to place its gems within the userâ€™s home folder, not in a system-wide location, and adds the local jekyll command to the userâ€™s PATH ahead of any system-wide paths. This is also useful for many shared webhosting services, where user accounts have only limited privileges. Adding these exports to .bashrc before running gem install jekyll bundler allows a complete non-sudo install of Jekyll. To activate the new exports, either close and restart Bash, logout and log back into your shell account, or run . .bashrc in the currently-running shell. If you see the following error when running the jekyll new command, you can solve it by using the above-described procedure: jekyll new test
Running bundle install in /home/user/test...
Your user account is not allowed to install to the system RubyGems.
You can cancel this installation and run:
    bundle install --path vendor/bundle
to install the gems into ./vendor/bundle/, or you can enter your password
and install the bundled gems to RubyGems using sudo.
Password:
 Once this is done, the jekyll new command should work properly for your user account. Jekyll & macOS With the introduction of System Integrity Protection in v10.11, several directories that were previously writable are now considered system locations and are no longer available. Given these changes, there are a couple of simple ways to get up and running. One option is to change the location where the gem will be installed (again, using sudo only if necessary): gem install -n /usr/local/bin jekyll
 Alternatively, Homebrew can be installed and used to set up Ruby. This can be done as follows: ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
 Once Homebrew is installed, the second step is to run: brew install ruby
 Advanced users (with more complex needs) may find it helpful to choose one of a number of Ruby version managers (RVM, rbenv, chruby, etc.) in which to install Jekyll. If you elect to use one of the above methods to install Ruby, it might be necessary to modify your $PATH variable using the following command: export PATH=/usr/local/bin:$PATH
 GUI apps can modify the $PATH as follows: launchctl setenv PATH "/usr/local/bin:$PATH"
 Either of these approaches are useful because /usr/local is considered a â€œsafeâ€ location on systems which have SIP enabled, they avoid potential conflicts with the version of Ruby included by Apple, and it keeps Jekyll and its dependencies in a sandboxed environment. This also has the added benefit of not requiring sudo when you want to add or remove a gem. Could not find a JavaScript runtime. (ExecJS::RuntimeUnavailable) This error can occur during the installation of jekyll-coffeescript when you donâ€™t have a proper JavaScript runtime. To solve this, either install execjs and therubyracer gems, or install nodejs. Check out issue #2327 for more info. Problems running Jekyll On Debian or Ubuntu, you may need to add /var/lib/gems/1.8/bin/ to your path in order to have the jekyll executable be available in your Terminal. Base-URL Problems If you are using base-url option like: jekyll serve --baseurl '/blog'
 â€¦ then make sure that you access the site at: http://localhost:4000/blog/index.html
 It wonâ€™t work to just access: http://localhost:4000/blog
 Configuration problems The order of precedence for conflicting configuration settings is as follows:  Command-line flags Configuration file settings Defaults  That is: defaults are overridden by options specified in _config.yml, and flags specified at the command-line will override all other settings specified elsewhere. Note: From v3.3.0 onward, Jekyll does not process node_modules and certain subdirectories within vendor, by default. But, by having an exclude: array defined explicitly in the config file overrides this default setting, which results in some users to encounter an error in building the site, with the following error message:     ERROR: YOUR SITE COULD NOT BE BUILT:
    ------------------------------------
    Invalid date '<%= Time.now.strftime('%Y-%m-%d %H:%M:%S %z') %>':
    Document 'vendor/bundle/gems/jekyll-3.4.3/lib/site_template/_posts/0000-00-00-welcome-to-jekyll.markdown.erb'
    does not have a valid date in front matter.
 Adding vendor/bundle to the exclude: list will solve this problem but will lead to having other sub-directories under /vendor/ (and also /node_modules/, if present) be processed to the destination folder _site. The proper solution is to incorporate the default setting for exclude: rather than override it completely: For versions up to v3.4.3, the exclude: setting must look like following: exclude:
  - Gemfile
  - Gemfile.lock
  - node_modules
  - vendor/bundle/
  - vendor/cache/
  - vendor/gems/
  - vendor/ruby/
  - any_additional_item # any user-specific listing goes at the end
 From v3.5 onward, Gemfile and Gemfile.lock are also excluded by default. So, in most cases there is no need to define another exclude: array in the config file. So an existing definition can either be modified as above, or removed completely, or commented out to enable easy edits in future. Markup Problems The various markup engines that Jekyll uses may have some issues. This page will document them to help others who may run into the same problems. Liquid Liquid version 2.0 seems to break the use of {{ in templates. Unlike previous versions, using {{ in 2.0 triggers the following error: '{{' was not properly terminated with regexp: /\}\}/  (Liquid::SyntaxError)
 Excerpts Since v1.0.0, Jekyll has had automatically-generated post excerpts. Since v1.1.0, Jekyll also passes these excerpts through Liquid, which can cause strange errors where references donâ€™t exist or a tag hasnâ€™t been closed. If you run into these errors, try setting excerpt_separator: "" in your _config.yml, or set it to some nonsense string. Production Problems If you run into an issue that a static file canâ€™t be found in your production environment during build since v3.2.0 you should set your environment to production. The issue is caused by trying to copy a non-existing symlink.  Please report issues you encounter!  If you come across a bug, please create an issue on GitHub describing the problem and any work-arounds you find so we can document it here for others.  
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/troubleshooting/


usage/index
-----------------------------------------------------------
Command Line Usage The Jekyll gem makes a jekyll executable available to you in your terminal. The jekyll program has several commands but the structure is always: jekyll command [argument] [option] [argument_to_option]
Examples:
    jekyll new site/ --blank
    jekyll serve --config _alternative_config.yml
 Typically youâ€™ll use jekyll serve while developing locally and jekyll build when you need to generate the site for production. For a full list of options and their argument, see Build Command Options. Here are some of the most common commands:  
jekyll new PATH - Creates a new Jekyll site with default gem-based theme at specified path. The directories will be created as necessary. 
jekyll new PATH --blank - Creates a new blank Jekyll site scaffold at specified path. 
jekyll build or jekyll b - Performs a one off build your site to ./_site (by default). 
jekyll serve or jekyll s - Builds your site any time a source file changes and serves it locally. 
jekyll clean - Removes all generated files: destination folder, metadata file, Sass and Jekyll caches. 
jekyll help - Shows help, optionally for a given subcommand, e.g. jekyll help build. 
jekyll new-theme - Creates a new Jekyll theme scaffold. 
jekyll doctor - Outputs any deprecation or configuration issues.  To change Jekyllâ€™s default build behavior have a look through the configuration options.
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/usage/


variables/index
-----------------------------------------------------------
Variables Jekyll traverses your site looking for files to process. Any files with front matter are subject to processing. For each of these files, Jekyll makes a variety of data available via Liquid. The following is a reference of the available data. Global Variables     Variable Description     site Site wide information + configuration settings from _config.yml. See below for details.   page Page specific information + the front matter. Custom variables set via the front matter will be available here. See below for details.   layout Layout specific information + the front matter. Custom variables set via front matter in layouts will be available here.   content In layout files, the rendered content of the Post or Page being wrapped. Not defined in Post or Page files.   paginator When the paginate configuration option is set, this variable becomes available for use. See Pagination for details.     Site Variables     Variable Description     site.time The current time (when you run the jekyll command).   site.pages A list of all Pages.   site.posts A reverse chronological list of all Posts.   site.related_posts If the page being processed is a Post, this contains a list of up to ten related Posts. By default, these are the ten most recent posts. For high quality but slow to compute results, run the jekyll command with the --lsi (latent semantic indexing) option. Also note GitHub Pages does not support the lsi option when generating sites.   site.static_files A list of all static files (i.e. files not processed by Jekyll's converters or the Liquid renderer). Each file has five properties: path, modified_time, name, basename and extname.   site.html_pages A subset of site.pages listing those which end in .html.   site.html_files A subset of site.static_files listing those which end in .html.   site.collections A list of all the collections (including posts).   site.data A list containing the data loaded from the YAML files located in the _data directory.   site.documents A list of all the documents in every collection.   site.categories.CATEGORY The list of all Posts in category CATEGORY.   site.tags.TAG The list of all Posts with tag TAG.   site.url Contains the url of your site as it is configured in the _config.yml. For example, if you have url: http://mysite.com in your configuration file, then it will be accessible in Liquid as site.url. For the development environment there is an exception, if you are running jekyll serve in a development environment site.url will be set to the value of host, port, and SSL-related options. This defaults to url: http://localhost:4000.   site.[CONFIGURATION_DATA] All the variables set via the command line and your _config.yml are available through the site variable. For example, if you have foo: bar in your configuration file, then it will be accessible in Liquid as site.foo. Jekyll does not parse changes to _config.yml in watch mode, you must restart Jekyll to see changes to variables.     Page Variables     Variable Description     page.content The content of the Page, rendered or un-rendered depending upon what Liquid is being processed and what page is.   page.title The title of the Page.   page.excerpt The un-rendered excerpt of a document.   page.url The URL of the Post without the domain, but with a leading slash, e.g. /2008/12/14/my-post.html   page.date The Date assigned to the Post. This can be overridden in a Postâ€™s front matter by specifying a new date/time in the format YYYY-MM-DD HH:MM:SS (assuming UTC), or YYYY-MM-DD HH:MM:SS +/-TTTT (to specify a time zone using an offset from UTC. e.g. 2008-12-14 10:30:00 +0900).   page.id An identifier unique to a document in a Collection or a Post (useful in RSS feeds). e.g. /2008/12/14/my-post/my-collection/my-document   page.categories The list of categories to which this post belongs. Categories are derived from the directory structure above the _posts directory. For example, a post at /work/code/_posts/2008-12-24-closures.md would have this field set to ['work', 'code']. These can also be specified in the front matter.   page.collection The label of the collection to which this document belongs. e.g. posts for a post, or puppies for a document at path _puppies/rover.md. If not part of a collection, an empty string is returned.   page.tags The list of tags to which this post belongs. These can be specified in the front matter.   page.dir The path between the source directory and the file of the post or page, e.g. /pages/. This can be overridden by permalink in the front matter.   page.name The filename of the post or page, e.g. about.md   page.path The path to the raw post or page. Example usage: Linking back to the page or postâ€™s source on GitHub. This can be overridden in the front matter.   page.next The next post relative to the position of the current post in site.posts. Returns nil for the last entry.   page.previous The previous post relative to the position of the current post in site.posts. Returns nil for the first entry.      ProTipâ„¢: Use Custom Front Matter  Any custom front matter that you specify will be available under page. For example, if you specify custom_css: true in a pageâ€™s front matter, that value will be available as page.custom_css.   If you specify front matter in a layout, access that via layout. For example, if you specify class: full_page in a layoutâ€™s front matter, that value will be available as layout.class in the layout and its parents.   Paginator     Variable Description     paginator.page The number of the current page   paginator.per_page Number of posts per page   paginator.posts Posts available for the current page   paginator.total_posts Total number of posts   paginator.total_pages Total number of pages   paginator.previous_page The number of the previous page, or nil if no previous page exists   paginator.previous_page_path The path to the previous page, or nil if no previous page exists   paginator.next_page The number of the next page, or nil if no subsequent page exists   paginator.next_page_path The path to the next page, or nil if no subsequent page exists      Paginator variable availability  These are only available in index files, however they can be located in a subdirectory, such as /blog/index.html.  
    Â© 2020 Jekyll Core Team and contributorsLicensed under the MIT license.
https://jekyllrb.com/docs/variables/
